//*******************************************************************
/// @file   MAIN.cpp
/// @brief  BeeIoT - Main file
/// @author MchResse
/// @date   2021-02-15
/// @details
// from Project https://github.com/mchresse/BeeIoT
//
// Description:
// Contains main setup() and loop() routines for esspressif32 platforms.
//
//----------------------------------------------------------
// Copyright (c) 2019-present, Randolph Esser
// All rights reserved.
// This file is distributed under the BSD-3-Clause License
// The complete license agreement can be obtained at:
//     https://github.com/mchresse/BeeIoT/license
// For used 3rd party open source see also Readme_OpenSource.txt
//*******************************************************************
//
// This Module contains code derived from
// - The "espressif/arduino-esp32/preferences" library,
//   distributed under the Apache License, Version 2.0
// - MQTT Library distributed under the MIT-License:
//   https://opensource.org/licenses/mit-license.php
// -
//
//
//*******************************************************************
// BeeIoT Local Libraries
//*******************************************************************
// For ESP32-DevKitC PIN Configuration look at BeeIoT.h


#include <Arduino.h>

#include "sys/types.h"
#include <iostream>
#include <string>
// #include <esp_log.h>
// from Espressif Systems IDF: https://github.com/espressif/esp-idf/tree/71b4768df8091a6e6d6ad3b5c2f09a058f271348/components/log
#include "soc/efuse_reg.h"
#include <esp_efuse.h>

//#include "sdkconfig.h"   // generated from Arduino IDE
#include <Preferences.h> // from espressif-esp32 library @ GitHub
// see https://github.com/espressif/arduino-esp32/blob/master/libraries/Preferences/examples/StartCounter/StartCounter.ino

#include <driver/gpio.h>
#include <driver/rtc_io.h>
#include <esp_sleep.h>
#include "soc/rtc_wdt.h"

#include "version.h"	// version file generated by buildscript_versioning.py script in project folder at build

// Libraries for SD card at ESP32_
// ...has support for FAT32 support with long filenames
#include <SPI.h>        // from Arduino IDE
#include <FS.h>         // from Arduino IDE
#include <SD.h>         // from Arduino IDE
#include "sdcard.h"

// DS18B20 libraries
#include <OneWire.h>            // from PaulStoffregen/OneWire library @ GitHub
#include <DallasTemperature.h>  // LGPL v2.1
#include "owbus.h"

// Espressif I2C Library
#include <driver/i2c.h>         // from esp-idf/components/driver/I2C.h library @ GitHub
#include "i2cdev.h"				// I2C master Port setup

// ESP32-ADC
#include "espadc.h"

// Libraries for to get time
#include "RTClib.h"             // from by JeeLabs adafruit /RTClib library @ GitHub

// Library fo HX711 Access
#include <HX711.h>              // HX711 library for Arduino (https://github.com/bogde/HX711)
#include "HX711Scale.h"         // local

#include <LoRa.h>       // Lora Lib from SanDeep (https://github.com/sandeepmistry/arduino-LoRa)
#include "BeeIoTWan.h"
#include "beelora.h"            // local: Lora Radio settings and BeeIoT WAN protocol definitions
#include "beeiot.h"             // local: provides all GPIO PIN configurations of all sensor Ports !

#include "DLED.h"				// local: Interface to RGB LED lib

// Libs for ePaper like WaveShare 2.7" or 2.9"
#include "epaper.h"

// #include <esp_task_wdt.h>

//************************************
// Global data object declarations
//************************************

#define LOOPTIME    600		// [sec] Loop wait time: in Seconds
#define SLEEPTIME   10		// RTC sleep time in seconds
#ifdef BEACON
#define SLEEPMODE	  BEACONSLEEP  // =0 initial startup needed(after reset); =1 after deep sleep;
								   // =2 after light sleep; =3 ModemSleep Mode; =4 Active Wait Loop
#else
#define SLEEPMODE	  1 		// =0 initial startup needed(after reset); =1 after deep sleep; =2 after light sleep;
							    // =3 ModemSleep Mode; =4 Active Wait Loop
#endif

// Define deep sleep options
// The requested sleep time (=Looptime) by GW for each new sensor support is set in 'report_interval'.
// Preset by LOOPTIME as default, but will finally redefined during JOIN Config request
// IF the requested report time is beyond max. RTC-Sleep time window we need loops of sleep phases:
// bootcounter = report interval / TIME_TO_SLEEP -> amount of sleep phases to reach tim of next reporting.
// Without JOIN-CFG we get:
// if report_interval < 78 Minutes (max RTC sleep time at once: 32bit counter in usec.: 2^32/1000000 = 4296 sec. / 60 = 71,58Min. ):
// 		report_interval = LOOPTME
// else:
// We need a counter of multiple of Sleeptime windows
// 		bootcount = report_interval / TIME_TO_SLEEP	-> amount of sleep loops by SLEEPTIME windows.
int TIME_TO_SLEEP	= SLEEPTIME;   // [sec.] default RTC sleep time window used in a sleep loop
// Default total sleep time (if LOOPTIME < 78Mn)
RTC_DATA_ATTR uint32_t  report_interval = LOOPTIME; // [sec.] initial interval between BIoT Reports; will be overwritten by CONFIG
RTC_DATA_ATTR int bootCount = 0;    // Deep Sleep Boot Counter

// WakeUp Source control
bool GetData = 0;				// =1 manual trigger by ISR (blue key) to start next measurement
RTC_DATA_ATTR int ReEntry = 0;	// =0 initial startup needed(after reset);   =1 after deep sleep;
								// =2 after light sleep; =3 ModemSleep Mode; =4 Active Wait Loop
// RTC timer is set in usec. -> so we need a factor
#define uS_TO_S_FACTOR  1000000LL  // Conversion factor for micro seconds to seconds
#define uS_TO_mS_FACTOR    1000LL  // Conversion factor for micro seconds to milli seconds


// Central Database of all measured values and runtime parameters
RTC_DATA_ATTR dataset		bhdb;

extern int iswifi;              // =1 WIFI flag o.k.
extern int isi2c;				// =1 I2C Master Port initialized
extern int isscale;				// =1 HX711 Scale ADC connected
extern int isrtc;               // =1 RTC device discovered and time read
extern int isadc;				// >0 => Addr of I2C ADC dev connected
extern int isntp;               // =1 bhdb has latest timestamp
extern int issdcard;            // =1 SDCard found flag o.k.
extern int isepd;               // =1 ePaper found
extern int islora;              // =1 LoRa client is active

extern SPIClass 	SPI2;		// Master SPI device
extern HX711        scale;      // managed in HX711Scale module
extern i2c_port_t 	i2c_master_port;	// I2C Master Port in i2cdev.cpp
extern int 			adcaddr;	// I2C Dev.address of detected ADC
extern OneWire 		ds;			// OneWire Bus object

#ifdef EPD2_CONFIG
	// reference on a ePaper Display object created in epd2.cpp
	extern GxEPD2_DISPLAY_CLASS<GxEPD2_DRIVER_CLASS, MAX_HEIGHT(GxEPD2_DRIVER_CLASS)>  display;
#endif
bool EPDupdate=true;			// =true: EPD update requested

// LoRa protocol frequence parameter
long lastSendTime = 0;			// last send time
char LoRaBuffer[256];			// buffer for LoRa Packages

//Battery Status
RTC_DATA_ATTR uint8_t bat_status = BAT_UNKNOWN;	// Status of battery state machine

//************************************
// Global function declarations
//************************************
void InitConfig(int mode);
void prepare_sleep_mode(int mode, uint64_t waittime);
esp_sleep_wakeup_cause_t print_wakeup_reason();
void BeeIoTSleep(void);
void biot_ioshutdown(int sleepmode);
void gpio_init(int sleepmode);
void get_efuse_ident(void);
void ResetNode(uint8_t p1, uint8_t p2, uint8_t p3);
void reset_RTCIO(void);

extern int sd_reset(uint8_t sdlevel);
extern void hexdump(unsigned char * msg, int len);

//*******************************************************************
/// @brief BeeIoT Setup Routine - Probe for all expected IO/Sensor devices
/// Detect and check functionality incl. test output where applicable
/// IO ports will be enabled depending on the wakeup mode.
/// @param none
/// @return void
//*******************************************************************
// Define Log level (search for Log values in beeiot.h)
// lflags = LOGBH + LOGOW + LOGHX + LOGLAN + LOGEPD + LOGSD + LOGADS + LOGSPI + LOGLORAR + LOGLORAW + LOGRGB;
RTC_DATA_ATTR uint32_t lflags = LOGBH;
//RTC_DATA_ATTR uint32_t lflags = 65535;
// works only in setup phase till LoRa-JOIN received Cfg data
// final value will be defined in BeeIoTParseCfg() by GW config data

void setup() {
int rc;		// generic return code variable

  // put your setup code here, to run once:
  	BHLOG(LOGBH) Serial.begin(115200);   // enable Ser. Monitor Baud rate

  // init pinmode and level of all used GPIO lines
	gpio_init(ReEntry);

	BHLOG(LOGBH) setup_LED();	// setup LED: Default LED Off
	BHLOG(LOGBH) LEDpulse(15);	// for tests get high pulses

	BHLOG(LOGBH)  setup_RGB();	// define RGB-LED control pin
	BHLOG(LOGRGB) setRGB(255,0,0); // start with RGB LED Off
	// RGBtest();

//***************************************************************
  //Print the wakeup reason for ESP32
  	BHLOG(LOGBH) Serial.printf("Main: BootCnt: %i - ReportInterval %i\n", bhdb.loopid, report_interval);
	rc = print_wakeup_reason();
	if(rc != ESP_SLEEP_WAKEUP_UNDEFINED){ // DeepSleep WakeUp Reason
      //  		BHLOG(LOGBH)Serial.printf("Main: DeepSleep Wakup (%i)\n", rc);

  		if(rc == ESP_SLEEP_WAKEUP_TIMER){
			// wakeup after predefined sleep time
			// Reentry remains unchanged
			ReEntry=1;
		}
  		if(rc == ESP_SLEEP_WAKEUP_EXT0){
			// wakeup after GPIO wakeup by Key 1
			// Reentry remains unchanged
			ReEntry=1;
		}
		// ReEntry > 1 <predefined startup/sleep mode set at end of Loop()>
		// 		=1 after deep sleep:  Reset MM -> wakeup with setup()
		// 		=2 after light sleep: keeps MM alive -> wakeup where sleep was called
		// 		=3 after ModemSleep Mode; ( not used here)
		// 		=4 Active Wait Loop (just a busy loop with delay())
	} else {
		ReEntry = 0;	// reset was pressed or PwrCycle -> set initial StartupState for setup action
		// Nexus of StartupMode set at end of a each loop()
	}

	// ReEntry mode is defined at end of setup phase for next sleep phase

//  	BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// Print welcome text
// +2ms
	if(!ReEntry) { // only at new POn cycle once
		if(lflags > 0){
			BHLOG(LOGBH) Serial.println();
			BHLOG(LOGBH) Serial.println(">***********************************<");
			BHLOG(LOGBH) Serial.printf ("> BeeIoT - BeeHive Weight Scale %s\n", VERSION_SHORT);
			BHLOG(LOGBH) Serial.println(">   by R.Esser (c) 2020-2023");
			BHLOG(LOGBH) Serial.println(">***********************************<");
			BHLOG(LOGBH) Serial.printf ("LogLevel: %i\n", lflags);
		}


		//***************************************************************
		// get bhdb.BoardID (=WiFI MAC), .ChipID and .ChipREV from eFuse area
		get_efuse_ident();
	}

  BHLOG(LOGBH) Serial.println("Start Sensor Setup Phase:");
  BHLOG(LOGRGB) setRGB(0,0,0); // end blinking of Red LED -> Start Setup Phase

//***************************************************************
// Preset BeeIoT runtime config values
// +25ms
  BHLOG(LOGBH) Serial.println("  Setup: Init runtime config settings");
  InitConfig(ReEntry);
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// I2C_master() has to be started always before setup_rtc() and setup_i2c_ADC/MAX()
// +2.8ms
  BHLOG(LOGBH) Serial.println("  Setup: I2C Master Device Port Init & Scan");
  setup_i2c_master(ReEntry);	// isi2c, isrtc, isads are set implictely
  if (!isi2c){
    BHLOG(LOGBH) Serial.println("         I2c Master port failed ");
    // enter exit code here, if needed
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// +25 ms
  BHLOG(LOGBH) Serial.println("  Setup: Init RTC Module DS3231 ");
  if (!setup_rtc(ReEntry)){
	BHLOG(LOGBH) Serial.println("         RTC setup failed");
	// enter exit code here, if needed (monitoring is hard without correct timestamp)
	// isrtc should be 0 here; hopefully NTP can help out later on
  }else{
	BHLOG(LOGLAN) rtc_test();
	// Time stamp of each loop loaded at begin of loop()
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// +3ms
  BHLOG(LOGBH) Serial.println("  Setup: SPI Device Ports: SD/LoRa/EPD2");
  issdcard = setup_spi(ReEntry);
  if (!issdcard){ // check LoRa port as reference
    BHLOG(LOGBH) Serial.println("         SPI setup: SD not detected");
    // enter here exit code, if needed
	// but LoRa and EPD are porbed later, and SD is not sytsem critical
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// +240 ms
  BHLOG(LOGBH) Serial.println("  Setup: HX711 Weight Cell");
  if (setup_hx711Scale(ReEntry)== 0){
    BHLOG(LOGBH) Serial.println("         HX711 setup failed");
    // enter here exit code, if needed
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// + ? (no SD: 10usec.)
  BHLOG(LOGBH) Serial.println("  Setup: SD Card");
  if((issdcard) && (bhdb.hwconfig & HC_SDCARD)){
    if (!setup_sd(ReEntry)){
      BHLOG(LOGBH) Serial.println("  SD: SD Card failed");
      // enter exit code here, if needed
    }
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// +2ms
  BHLOG(LOGBH) Serial.println("  Setup: LoRa SPI device & Base layer");
  if (!setup_LoRa(ReEntry)){
    BHLOG(LOGBH) Serial.println("         LoRa Base layer setup failed");
    // enter exit code here, if needed
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// +22ms
  BHLOG(LOGBH) Serial.println("  Setup: OneWire Bus setup");
  if (setup_owbus(ReEntry) == 0){
    BHLOG(LOGBH) Serial.println("         No OneWire devices found");
    // enter exit code here, if needed
  }else{
    BHLOG(LOGOW) GetOWsensor(); // read temperature once the first time
  }
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// +1,2ms
#ifdef EPD2_CONFIG
  BHLOG(LOGBH)Serial.println("  Setup: ePaper2");
  if (setup_epd2(ReEntry) == 0){
    BHLOG(LOGBH)Serial.println("         EPD2 ePaper2 Setup failed");
  }
#endif // EPD2
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// Init battery State machine
  if (ReEntry==0){
  	BHLOG(LOGBH)Serial.println("   Start: Battery State control");
  	bat_control(0.0, true);	// (re-)initialize Battery state machine once
  }

//  BHLOG(LOGBH) LEDpulse(1);

  //***************************************************************
// Setup ESP32 WatchDog Timer

if(0) {		// if(rtc_wdt_is_on){
	unsigned int timeout;
  	BHLOG(LOGBH)Serial.println("   WDT: Enabled");
	rtc_wdt_get_timeout(RTC_WDT_STAGE0, &timeout);
  	BHLOG(LOGBH)Serial.printf("RTC Timeout: %i ms on Stage%d", timeout, RTC_WDT_STAGE0);
	rtc_wdt_get_timeout(RTC_WDT_STAGE1, &timeout);
  	BHLOG(LOGBH)Serial.printf(" -- %i ms on Stage%d\n", timeout, RTC_WDT_STAGE1);
//  rtc_wdt_set_time(RTC_WDT_STAGE0, 10000);	// 10sec. feeding time
//	rtc_wdt_set_stage(RTC_WDT_STAGE0, RTC_WDT_STAGE_ACTION_RESET_SYSTEM);
//	rtc_wdt_set_stage(RTC_WDT_STAGE1, RTC_WDT_STAGE_ACTION_RESET_SYSTEM);
	rtc_wdt_set_stage(RTC_WDT_STAGE0, RTC_WDT_STAGE_ACTION_OFF );	// Disable Action of RTC WDT
	rtc_wdt_set_stage(RTC_WDT_STAGE1, RTC_WDT_STAGE_ACTION_OFF );	// Disable Action of RTC WDT
	rtc_wdt_protect_off();
	rtc_wdt_disable();	// Finally Disable RTC WDT itself
}

//***************************************************************
// initial sleep mode for next loop:
//   =1 after deep sleep; =2 after light sleep; =3 ModemSleep Mode; =4 Active Wait Loop
  ReEntry = SLEEPMODE;

//  BHLOG(LOGBH) LEDPulse(1);
  BHLOG(LOGBH) Serial.println("");

} // end of BeeIoT setup()



//*******************************************************************
/// @brief  BeeIoT Main Routine: Loop() used as endless loop
///	@details 1. Init BHDB row for measurement + RTC timestamp
/// 		2. Sample HX711 connected Weight cell
///  		3. Sample OW Temp. sensors (Int/Ext/Hive)
///			4. Assure Battery Power Level by ESP ADC lines
///			5. Collect and prepare LogData Map for distribution
///			6. If LoRa: send logdata in Bin format (DSENSOR)
///						if BeaconMode: send compact beacon message
///			7. If SD: save logdata in CSV format to *.csv file on SD
///					  save runtime tracedata to *.txt file on SD
///			8. Update ePaper Display
///			9. prepare next loop start
///			10. Enter sleep mode by timer + EPD-Key4 wakeup trigger enabled
///				Shutdown Sensor + GPIO line for low power (deep)sleep mode
///			    (If DeepSleep -> Wakeup starts with setup()-init again.)
/// @param none
/// @return none
//*******************************************************************
void loop() {
// put your main code here, to run repeatedly:
//    Serial.println("Hello from loop");
//   	delay(1000);
//  	BHLOG(LOGBH) LEDtoggle();
// return;
int cnum;

  	BHLOG(LOGRGB) setRGB(0,255,0);  // show start of new loop() phase: green
	BHLOG(LOGBH) LEDpulse(15);

//***************************************************************
// 1. Get current time to bhdb
// +4,7ms
  if(getTimeStamp() == -2){   // no valid time source found (RTC or NTP)
    strncpy(bhdb.dlog.timeStamp, "0000-00-00 00:00:00", LENTMSTAMP);
  }else{
    // store curr. timstamp for next data row
    sprintf(bhdb.dlog.timeStamp, "%s %s", bhdb.date, bhdb.time);
  }

  BHLOG(LOGBH) Serial.println(">************************************************<");
  BHLOG(LOGBH) Serial.printf ("> Start of BeeIoT Weight Scale loop %i - %s\n",
  				bhdb.loopid, bhdb.dlog.timeStamp);

  cnum=sprintf(bhdb.dlog.comment, "o.k.");
  if(cnum>0)
	bhdb.dlog.comment[cnum]=0;	// add ending '0'

//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// 2. Get Weight Scale values
// +840ms
#ifdef HX711_CONFIG
float weight =0;

  if(isscale==1){
	scale.power_up();  // HX711 WakeUp Device

	// Acquire unit reading
	weight = HX711_read(1);	// get it in 10 Gr. steps
	BHLOG(LOGHX) Serial.printf("  HX711: Weight(unit): %.3f kg\n", weight);
	bhdb.dlog.HiveWeight = weight;

	scale.power_down();
  }

  bhdb.dlog.HiveWeight = weight;
#endif // HX711_CONFIG

//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// 3. Scan OW Temp. Sensors
// +600ms
#ifdef ONEWIRE_CONFIG
	int owsensors;
	int retry=0;
	// Get all temp values directly into bhdb.dlog[]
	do{
		owsensors = GetOWsensor();
    	if(owsensors >= OW_MAXDEV){	// min expected # of sensor data found ?
		    // check if value of last of all 3 sensors is in range
		    if(	(bhdb.dlog.TempIntern > -98) &
				(bhdb.dlog.TempExtern > -98) &
				(bhdb.dlog.TempHive   > -98) )
        	{
				BHLOG(LOGOW) Serial.printf("  OWBus: %i Temp Sensor Data retrieved\n", owsensors);
				break; // seems we have all values in place > leave retry loop
			}
		}
		BHLOG(LOGOW) Serial.printf("  OWBus: No valid Temp-data after %i retries\n", retry);
		retry++;
		mydelay2(200,0);			// sleep 200ms for OW bus recovery
		if(retry > 0)
			cnum = sprintf(bhdb.dlog.comment, "OW-%ix", retry);
			if(cnum>0)
				bhdb.dlog.comment[cnum]=0;	// add ending '0'
	} while (retry <= ONE_WIRE_RETRY);

#endif // ONEWIRE_CONFIG

//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// 4. Monitor Battery Power via ESP32 analog ports
// +0.6ms

  // Read Analog Ports via internal ESP32-ADC
  // read out all Aanalog channels:
	uint32_t addata = 0;   		// raw ADS Data buffer

	// Read Charging Power in Volt
	#define VUSB_LEVEL	+7
	addata = (getespadc(Charge_pin) + VUSB_LEVEL)  * 306 / 100;			// get ADC Vin corrected by ext. Resistance devider
  	bhdb.dlog.BattCharge = addata; 		//  measured: 5V/3,3 = 1,63V value (Dev-R: 33k / 69k)
	BHLOG(LOGADS) Serial.print("  BMS: Get Batt.Power Level: V-Charge=");
  	BHLOG(LOGADS) Serial.print((float)addata/1000, 2);

  	// Get battery Powerlevel & calculate % Level
	#define VBAT_LEVEL	-29
	float x;              		// Volt calculation buffer
	addata = (getespadc(Battery_pin) + VBAT_LEVEL) * 316 / 100;			// get ADC Vin corrected by ext. Resistance devider
	x = (float)addata-BATTERY_SHUTDOWN_LEVEL;
	if( x > 0.0){
	  	x = (x / (float)(BATTERY_MAX_LEVEL-BATTERY_SHUTDOWN_LEVEL) ) * 100;			//  measured: Vbatt/3 = 1,20V value (Dev-R: 33k / 69k)
	}else{
		x=0.0;
	}
	bhdb.dlog.BattLevel = (int16_t) x;
  	bhdb.dlog.BattLoad = (uint16_t) addata;
  	BHLOG(LOGADS) Serial.print("V-Battery=");
  	BHLOG(LOGADS) Serial.printf("%.2fV (%i%%)\n", (float)addata/1000, bhdb.dlog.BattLevel);

	// Update Charge Control State machine by Battery Power Level
	//	bat_control((float) addata, false);	// Evaluate BAT Level + Error handling

//  BHLOG(LOGBH) LEDpulse(1);	// Battery handling done

//***************************************************************
// 5.+ 6.+ 7.  save all collected sensor data to SD and/or report via LoRa/Wifi
// + 840 ms

  Logdata();
//  BHLOG(LOGBH) LEDpulse(1);

//***************************************************************
// 8. Update ePaper
// 2440ms
#ifdef EPD2_CONFIG
#ifdef BEACON
	showbeacon2();
	BHLOG(LOGLORAW) Serial.println("  LORA: Send Beacon Message");
#else
	showdata();
#endif
#endif

// end of sensor loop
  BHLOG(LOGRGB) setRGB(0,0,255);  // show end of loop() phase: blue
  BHLOG(LOGBH) LEDpulse(15);

//***************************************************************
// 9. Calculate next loop Index
  bhdb.loopid++;     // Increment LoopID for next loop
  BHLOG(LOGBH) LEDOff();

//***************************************************************
// 10. End of Main Loop ->  Save data and enter Sleep/Delay Mode
  // Start sleep/wait loop
  BHLOG(LOGBH) printf(" -> Start preparing Sleep Mode\n");
	prepare_sleep_mode(ReEntry, (uint32_t) report_interval); // intervall in seconds

	// In DeepSleep Mode this point is never reached

} // end of loop()



//*********************************************************************************
///@brief Logdata() Append current sensor data set to SD card -> logdata file
// and send it via LoRaWAN
//
///@param global bhdb
//***********************************************************************************
void Logdata(void) {
String  dataMessage; 		// Global data objects
biot_dsensor_t	dsensor;	// sensor data stream pkg in binary format

  	dsensor.logid		= bhdb.loopid;
  	dsensor.year2k		= bhdb.stime.tm_year - 100;	// rebase 1900 -> 2000
	dsensor.month		= bhdb.stime.tm_mon+1;		// 1-12
	dsensor.day			= bhdb.stime.tm_mday;		// 1-31
	dsensor.hh			= bhdb.stime.tm_hour;
	dsensor.mm			= bhdb.stime.tm_min;
	dsensor.ss			= bhdb.stime.tm_sec;
	dsensor.weight		= bhdb.dlog.HiveWeight * 100.0;	// in 10 Gramm steps; save 1 digit
	dsensor.text		= bhdb.dlog.TempExtern * 100.0;
	dsensor.tint		= bhdb.dlog.TempIntern * 100.0;
	dsensor.thive		= bhdb.dlog.TempHive * 100.0;
	dsensor.trtc		= bhdb.dlog.TempRTC * 100.0;
	dsensor.board3v		= 0;
	dsensor.board5v 	= 0;
	dsensor.battcharge	= bhdb.dlog.BattCharge;
	dsensor.battload	= bhdb.dlog.BattLoad;
	dsensor.battlevel	= bhdb.dlog.BattLevel;

	dsensor.tlen 		= strlen(bhdb.dlog.comment);
	if(dsensor.tlen > BIoT_NOTICELEN){
		dsensor.tlen = BIoT_NOTICELEN;	// assure max. text length value (normally already done by snprintf)
	}
	dsensor.tlen = snprintf((char*) dsensor.notice, dsensor.tlen , "%s", (char*) bhdb.dlog.comment);
	if(dsensor.tlen < 0){
		dsensor.tlen = 0;	// if snprintf failed -> define no text field
	}

	// CRC calcuation basically not needed: data assurance is already done by LoRa chip by CRC
	dsensor.crc8	=0x00;	//ToDo -> provide evaluation of DSENSOR Data by CRC8 calculation
	size_t dslen = BIoT_DSENSORLEN - BIoT_NOTICELEN + dsensor.tlen; // calc. datamap length

	// Write the sensor readings onto the SD card
/*
	// in Binary Format
	if(issdcard){
	  if(bhdb.hwconfig & HC_SDCARD) {	// SDCard access enabled by PCFG
    	appendBinFile(SD, SDLOGPATH, (const uint8_t*) &dsensor, dslen);
	  }
	} else {
    	BHLOG(LOGSD) Serial.println("  Log: No SDCard, no local Logfile...");
	}
*/

	// in DSENSOR2 Mode: (ASCII) data format
	// Create ASCII Status Report based on the sensor readings
  	dataMessage =
              String(bhdb.date) + " " +
              String(bhdb.time) + "," +
              String(bhdb.dlog.HiveWeight) + "," +
              String(bhdb.dlog.TempExtern) + "," +
              String(bhdb.dlog.TempIntern) + "," +
              String(bhdb.dlog.TempHive)   + "," +
              String(bhdb.dlog.TempRTC)    + "," +
              String((float)bhdb.dlog.BattCharge/1000) + "," +
              String((float)bhdb.dlog.BattLoad/1000)   + "," +
              String(bhdb.dlog.BattLevel)  + "#" +
              String(bhdb.loopid) + " " +
              String(bhdb.dlog.comment) +
              "\r\n";       // OS common EOL: 0D0A
#ifndef BEACON
  Serial.printf("  Loop[%i]: ", bhdb.loopid);
  Serial.print(dataMessage);

  // Write the sensor readings onto the SD card
  if(issdcard){
 	  if(bhdb.hwconfig & HC_SDCARD) {	// SDCard acces enabled by PCFG
	    appendFile(SD, SDLOGPATH, dataMessage.c_str());
	   }
  }else{
    BHLOG(LOGSD) Serial.println("  Log: No SDCard, no local Logfile...");
  }
#endif	// No BEACON


  // Send Sensor report via BeeIoT-LoRa ...
  if(islora){  // do we have an active connection (joined ?) and enough power
#ifdef BEACON
    // For Test purpose of transmission quality: send a beacon to the current GW
    BeeIoTBeacon(0);  // in Non-Joined Mode != BIOT_JOIN (assumed LoRa Log was successfull)
#else

//	if(bhdb.dlog.BattLevel > 0){
#ifdef DMSG
    LoRaLog((const byte *) dataMessage.c_str(), (byte)dataMessage.length(), 0); // in sync mode
#else
    LoRaLog((const byte *) &dsensor, dslen, 0); // in sync mode
#endif // DMSG
//	}else{
//    	BHLOG(LOGLORAW) Serial.println("  Log: No power left for LoRa -> Skipped.");
//	}
#endif // BEACON

  }else{
    BHLOG(LOGLORAW) Serial.println("  Log: No LoRa, no BeeIoTWAN on air ...");
  }

  return;
}

//*******************************************************************
/// @brief Simple Wait - Busy loop method
/// @param tval 	waittime in millisec
/// @param Getdata	Flag from GPIO35-BlueKey-ISR routine =1 -> stop busy loop
/// @details
///		250ms busy loop: lets blink Red LED each 0,5sec.
/// @return void
//*******************************************************************
void mydelay(int32_t tval){
  int fblink = tval / 1000;   // get # of seconds == blink frequence
  int i;
  for (i=0; i < fblink/2; i++){
	BHLOG(LOGRGB) setRGB(0,0,255);	// show start of delay loop

	delay(20);			// blink 20ms second
	BHLOG(LOGRGB) setRGB(0,0,0);		// show start of new loop() phase

    delay(750);			// wait 0.75 second
	if(GetData){  		// Semaphor controlled by GPIO35 Key (blue button)
		// user wants next measurement loop
		GetData = 0;	// reset loop trigger flag
		BHLOG(LOGRGB) setRGB(255,0,0); // show start of new loop() phase
		return;			// and start next measurement loop
	}
  } // wait loop
  BHLOG(LOGRGB) setRGB(255,0,0); // show start of new loop() phase
}

//*******************************************************************
/// @brief Simple Wait - by light sleep method: MM keeps active
/// @param waitms 	waittime in millisec
/// @param initdelay gracetime for trigger timer initiaÃ¶ization in msec.
/// @details
/// 	ESP32 to enter light sleep mode
/// 	GPIO35-BlueKey configured as async wakup trigger
/// @return void
//*******************************************************************
esp_err_t mydelay2(int32_t waitms, int32_t initdelay){
#define uS_TO_mS_FACTOR 1000LL  /* Conversion factor for micro seconds to milli seconds */
esp_err_t rc;

  	BHLOG(LOGRGB) setRGB(0,0,255);  // show start of delay loop

	// BHLOG(LOGBH) Serial.printf("  Main-Dly2: Light Sleep - Trigger: Timer(%i ms) + GPIO%d(blue Key4)\n", waittime, EPD_KEY1);
	gpio_wakeup_enable(EPD_KEY1, GPIO_INTR_LOW_LEVEL);	// set GPIO35 (blue key4 button) as trigger in low level
	esp_sleep_enable_gpio_wakeup();

	// Configure the wake up timer source
	rc = esp_sleep_enable_timer_wakeup(uint64_t (waitms) * uS_TO_mS_FACTOR);	// time in us
	if(rc != ESP_OK){
		BHLOG(LOGBH) Serial.printf("  Main-Delay2: LightSleep timer setup failed: 0x%X\n", rc);
		return(rc);
	}
	rc = esp_light_sleep_start();	// start in light sleep now; keep Mem powered -> no data loss

	// Runtime workflow after Light sleep continues here...
	if(rc != ESP_OK){
		BHLOG(LOGBH) Serial.printf("  Main-Delay2: LightSleep failed: 0x%X\n", rc);
		BHLOG(LOGBH) delay(5000);	// wait some time to show the message
		mydelay(waitms);			// use classic wait loop instead -> but no Low power mode !!!
	}
  	BHLOG(LOGRGB) setRGB(255,0,0);  // show sensor loop-phase (green)

	return(rc);
}


//*******************************************************************
/// @brief initialize static configuration settings of housekeeping data
/// @param reentry 0..4 wakeup mode
/// @details
///		=0 initial startup needed(after reset)
/// 	=1 after deep sleep /Ram destroyed, except RTC Mem)
/// 	=2 after light sleep (Ram up to date)
///		=3 ModemSleep Mode (not used)
///		=4 Active Wait Loop using delay()
/// @return void
//*******************************************************************
void InitConfig(int reentry){
int i;
int cnum;

  	if(!reentry){ // do init only once after Power-On
		bhdb.loopid       = 0;
		bhdb.formattedDate[0] = 0;
		bhdb.date[0]      = 0;
		bhdb.time[0]      = 0;
		bhdb.chcfgid	  = 0;
		bhdb.woffset	  = (int) scale_OFFSET;

		// Enable HW components flags	<- may get overwritten by pcfg.hwconfig at each JOIN
		bhdb.hwconfig	  = 0;
#ifdef LORA_CONFIG
		bhdb.hwconfig	  += HC_LORA; 	// LoRa is minimum unless pcfg is needed for remote control
#endif
#ifdef EPD_CONFIG
		bhdb.hwconfig	  += HC_EPD;
#endif
#ifdef EPD2_CONFIG
		bhdb.hwconfig	  += HC_EPD;
#endif
#ifdef SD_CONFIG
		// can be actively switched on/off by HWconfig RX1 command later; default=on
		bhdb.hwconfig	  += HC_SDCARD;
#endif
#ifdef WIFI_CONFIG
		bhdb.hwconfig	  += HC_WIFI;
#endif
#ifdef NTP_CONFIG
		bhdb.hwconfig	  += HC_NTP;
#endif
#ifdef BEACON
		bhdb.hwconfig	  += HC_BEACON;
#endif

		// bhdb.BoardID      = 0;  already defined
		bhdb.dlog.index       =0;
		bhdb.dlog.timeStamp[0]=0;
		bhdb.dlog.HiveWeight  =0;
		bhdb.dlog.TempExtern  =0;
		bhdb.dlog.TempIntern  =0;
		bhdb.dlog.TempHive    =0;
		bhdb.dlog.TempRTC     =0;
		bhdb.dlog.BattCharge  =0;
		bhdb.dlog.BattLoad    =0;
		bhdb.dlog.BattLevel   =0;
		bhdb.dlog.BattFullCnt =0;
  	}	 // end of !reentry

	cnum=sprintf(bhdb.dlog.comment, "OK");
	if(cnum>0){
		bhdb.dlog.comment[cnum]=0;
	}
} // end of InitConfig()


//*******************************************************************
/// @brief gpio_init()
/// Initialize pinmode and level for all used GPIO lines
///
/// @param sleepmode	wakeup mode: 1= deep sleep, 2=light sleep
/// @details 1 DeepSleep Mode; 2 LightSleep Mode; 3 ModemSleep; 4 Active wait loop
/// @return void
//*******************************************************************
void gpio_init(int sleepmode){
		// coming from Deep sleep
		gpio_hold_dis(SPIPWREN);	// required for all SPi devices
		gpio_hold_dis(EPDGNDEN);	// release GND pin of EPD

		gpio_hold_dis(LEDRGB);
		gpio_hold_dis(LEDRED);		// No RTC

		gpio_hold_dis(SD_CS);   	// enable SD_CS
		gpio_hold_dis(EPD_CS);   	// enable EPD_CS
		gpio_hold_dis(LoRa_CS);  	// enable LoRa_CS
		gpio_hold_dis(SPI_SCK);
		gpio_hold_dis(SPI_MOSI);
		gpio_hold_dis(SPI_MISO);

		gpio_hold_dis(LoRa_DIO0);	// no RTC
		//	gpio_hold_dis(LoRa_RST);	// NC

		gpio_hold_dis(EPD_BUSY);	// no RTC -> Input
		gpio_hold_dis(EPD_DC);		// no RTC
		gpio_hold_dis(EPD_RST);

		gpio_hold_dis(I2C_SCL);
		gpio_hold_dis(I2C_SDA);

		gpio_hold_dis(RTC_INT);		 // RTC-INT\ pin

		gpio_hold_dis(HX711_SCK);  		// HX711 SCK		// no RTC pin
		gpio_hold_dis(HX711_DT);   		// HX711 Data		// no RTC pin

		gpio_hold_dis(ONE_WIRE_BUS);

		gpio_hold_dis(EPD_KEY1);
		gpio_hold_dis(EPD_KEY2);
		//    gpio_hold_dis(EPD_KEY3);
		//    gpio_hold_dis(EPD_KEY4);

	    gpio_deep_sleep_hold_dis();	// Disables all DeepSleep Hold function

	// For test purpose: set LED / RGB-LED ports
		pinMode(LEDRGB, OUTPUT);
		pinMode(LEDRED, OUTPUT);
		digitalWrite(LEDRGB, LOW); // signal Setup Phase
		digitalWrite(LEDRED, LOW); // signal Setup Phase


	// First disabe all SPI devices CS line to avoid collisions
		pinMode(EPD_CS, OUTPUT);    // SPI-CS for ePaper EPD
		pinMode(SD_CS,  OUTPUT);    // SPI-CS for SDCard Port
		pinMode(LoRa_CS, OUTPUT);	// SPI-CS for LoRa Port
		digitalWrite(EPD_CS, HIGH);
		digitalWrite(SD_CS, HIGH);
		digitalWrite(LoRa_CS, HIGH);

	// Activate SPI Power switch -> attach 3.3V for epaper/LoRA/SD
		pinMode(SPIPWREN, OUTPUT);
		digitalWrite(SPIPWREN, HIGH); // enable SPI device Power
		pinMode(EPDGNDEN, OUTPUT);
		digitalWrite(EPDGNDEN, LOW);  // enable EPD Ground low side switch

	// Setup SPI BUS Control lines
		pinMode(SPI_SCK, OUTPUT);
		pinMode(SPI_MOSI, OUTPUT);
		pinMode(SPI_MISO, INPUT);
		digitalWrite(SPI_SCK, HIGH);
		digitalWrite(SPI_MOSI, HIGH);

	// Preset LoRa Module Control lines
		pinMode(LoRa_DIO0, INPUT);
		//    pinMode(LoRa_RST, OUTPUT);	// NC
		//	  digitalWrite(LoRa_RST, HIGH);	// NC

	// Preset SPI dev: EPD Display Module
		digitalWrite(EPD_DC, HIGH);
		digitalWrite(EPD_RST, HIGH);
		pinMode(EPD_BUSY, INPUT);
		pinMode(EPD_DC, OUTPUT);
		pinMode(EPD_RST, OUTPUT);

	// Panel Key 1-4
		pinMode(EPD_KEY1, INPUT);	// +ext. Pullup
		pinMode(EPD_KEY2, INPUT);	// +ext. Pullup
	//	pinMode(EPD_KEY3, INPUT);	// NC
	//	pinMode(EPD_KEY4, INPUT);	// NC

	// Preset I2C Master Port
		pinMode(I2C_SCL, OUTPUT);		// I2C Bus Clock line
		pinMode(I2C_SDA, INPUT);		// I2C Data line start with defensive input
		digitalWrite(I2C_SCL, HIGH);	// define default level

	// RTC INT\ line
		pinMode(RTC_INT, INPUT);		// RTC Data line with no Pullup

	// HX requires OUTPUT here to define data/clock line during sleep
	//    pinMode(HX711_SCK, OUTPUT);
	//    pinMode(HX711_DT, INPUT);		// Data port starts with defensive Input state
	//	digitalWrite(HX711_SCK, HIGH);

	// Set OneWire line to Master port
		pinMode(ONE_WIRE_BUS, INPUT);	// finally with ex. pullup 10k -> Start with defensive Input

	// BATCHARGEPIN fully controlled by bat_control()
}


//*******************************************************************
/// @brief biot_ioshutdown()
/// disable all hi level IO protocol devices (e.g. SPI)
/// and prepare IO ports for sleep mode accordingly,
/// Be aware only GPIOs with RTC functionality can be stabilzated in
/// a configured mode: 0,2,4,12-15,25-27,32-39
/// @param sleepmode	wakeup mode
/// @details 1 DeepSleep Mode; 2 LightSleep Mode; 3 ModemSleep; 4 Active wait loop
/// @return void
//*******************************************************************
void biot_ioshutdown(int sleepmode){

    BHLOG(LOGSPI) Serial.println("  MAIN: shutdown sensor devices");
  	BHLOG(LOGBH) setRGB(0,0,0);	// SHow blink of SHutdown start by Blue LED

if(sleepmode == 1)
{
	// Shutdown all SPI devices
#ifdef SD_CONFIG
    if(issdcard){
      SD.end();   // unmount SD card
	  issdcard = 0;
    }
#endif

#ifdef EPD2_CONFIG
	if(isepd){
		display.powerOff();
//    	display.hibernate();
		isepd = 0;
	}
#endif

#ifdef LORA_CONFIG
    if(islora){
      LoRa.end();     // set LORA Radio to sleep mode and disable SPI
      islora = 0;
    }
#endif

	SPI2.end();		// Detach all SPI Bus pins

	// in deep sleep we have to stabilize CS+RST lines of SPI devices
	// keep stable state in Deep sleep for all SPI-CS lines
	digitalWrite(SD_CS, HIGH);
	digitalWrite(LoRa_CS, HIGH);
//	digitalWrite(EPD_CS, HIGH);
	  pinMode(EPD_CS, INPUT);
	rtc_gpio_isolate(SD_CS);
	rtc_gpio_isolate(LoRa_CS);
//	rtc_gpio_isolate(EPD_CS);
	gpio_hold_en(SD_CS);
	gpio_hold_en(LoRa_CS);
//	gpio_hold_en(EPD_CS);

	// SPI Bus shutdown: EPD + LORA + SD
    pinMode(SPI_MISO, INPUT);
    pinMode(SPI_MOSI, INPUT);
    pinMode(SPI_SCK,  INPUT);
	rtc_gpio_isolate(SPI_MISO);
	rtc_gpio_isolate(SPI_MOSI);
	rtc_gpio_isolate(SPI_SCK);
	gpio_hold_en(SPI_MISO);
	gpio_hold_en(SPI_MOSI);
	gpio_hold_en(SPI_SCK);


	pinMode(EPD_BUSY, INPUT);		// already output by EPD -> so ESP-Input by default
	pinMode(EPD_RST, OUTPUT);		// EPD: keep RST = Output
	pinMode(EPD_DC,  INPUT);		// no RTC pin
	rtc_gpio_isolate(EPD_BUSY);
	rtc_gpio_isolate(EPD_RST);
	gpio_hold_en(EPD_BUSY);
	gpio_hold_en(EPD_RST);

	// Switch off SPI power switch of SPI device back to LOW
    digitalWrite(SPIPWREN, LOW);	// Low if P-channel MOSFET
	rtc_gpio_isolate(SPIPWREN);		// isolate internal PUP/PDN
	gpio_hold_en(SPIPWREN);			// could be also INput -> ext. 100k pulldown

	digitalWrite(EPDGNDEN, LOW);   	// Enable EPD Ground low side switch
//    pinMode(EPDGNDEN, INPUT);		// no RTC pin
	gpio_hold_en(EPDGNDEN);			//


	// HX requires OUTPUT here to define data/clock line during sleep
	//    pinMode(HX711_SCK, INPUT_PULLUP);
	//    pinMode(HX711_DT, INPUT_PULLUP);
	digitalWrite(HX711_SCK,HIGH);
	digitalWrite(HX711_DT,HIGH);
	gpio_hold_en(HX711_SCK);  		// HX711 SCK		// no RTC pin
	gpio_hold_en(HX711_DT);   		// HX711 Data		// no RTC pin

	//	i2c_driver_delete(i2c_master_port);
    // Set all I2C lines to high impedance -> open collector bus
    pinMode(I2C_SCL, INPUT);		// /w ext- pullup 4k7, no RTC GPIO
    pinMode(I2C_SDA, INPUT);		// /w ext- pullup 4k7, no RTC GPIO
	rtc_gpio_isolate(I2C_SCL);    	// ADS_SCL
	rtc_gpio_isolate(I2C_SDA);    	// ADS_SDA
//	gpio_hold_en(I2C_SCL);    		// ADS_SCL
//	gpio_hold_en(I2C_SDA);    		// ADS_SDA

	// RTC Chip DS3231
	pinMode(RTC_INT, INPUT);
	rtc_gpio_isolate(RTC_INT);

	// Set OW line to high impedance -> open collector bus
    pinMode(ONE_WIRE_BUS, INPUT);	// finally with ex. pullup 10k -> set only to RTC INPUT
	//  gpio_hold_en(ONE_WIRE_BUS); // OneWire Bus line
	rtc_gpio_isolate(ONE_WIRE_BUS); // OneWire Bus line
//	gpio_hold_en(ONE_WIRE_BUS);

	// LEDRGB has already internal 10k pullup
    pinMode(LEDRGB, INPUT);
//	gpio_hold_en(LEDRGB);

    pinMode(LEDRED, OUTPUT); 		// finally pulled up by LED, No RTC GPIO
	digitalWrite(LEDRED, LOW);
//	gpio_hold_en(LEDRED);			// no RTC IO

	// Keep BAT Charge control pin as it is
	gpio_hold_en(BATCHARGEPIN);

    BHLOG(LOGSPI) Serial.println("  MAIN: shutdown to sleep mode 2 done !");

} else if(sleepmode == 2)
	{

	} // end of sleepmode 2

} // biot_ioshutdown()



//***********************************************************************
/// @brief Method to print the reason by which ESP32
/// has been awaken from sleep
/// @param Mode	1=DeepSleep Mode; 2=LightSleep Mode;
/// 		3=ModemSleep;
/// 		4=Active wait loop sleeptime -> loop time - value in seconds
/// @param waittime sleep/wait time in seconds
/// @return void
//***********************************************************************
void prepare_sleep_mode(int mode, uint64_t waittime){
esp_err_t  rc;

	biot_ioshutdown(mode);          // disable all IO devices and their IO Ports.

	switch(mode){
		case 1:		// DeepSleepMode

			// Next we decide what all peripherals to shut down/keep on.
			//	By default, ESP32 will automatically power down the peripherals
			//	not needed by the wakeup source,
    		//  Details at the API docs
			//	http://esp-idf.readthedocs.io/en/latest/api-reference/system/deep_sleep.html

      		//	BHLOG(LOGBH) Serial.println("  Main: Configure all RTC Peripherals to be powered");
    		// Keep power domain enabled in deep sleep, if it is needed by one of the wakeup options.
      		// Otherwise power it down.
	   		esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_AUTO);

			rc = esp_sleep_enable_ext0_wakeup(EPD_KEY1, 0);	// select Key1 (blue button) as Wakup Trigger on low level
    		BHLOG(LOGBH) Serial.printf("  Main: Deep Sleep - Trigger: Timer(%i sec.) + GPIO%d(green Key1)\n", (uint32_t)waittime, EPD_KEY1);
			if(rc != ESP_OK){
				BHLOG(LOGBH) Serial.printf("  Main: DeepSleep wakeup setup failed: %i\n", rc);
			}

    		gpio_deep_sleep_hold_en();  // freeze all settings from above during deep sleep time
    		// reactivation after deep sleep in setup_multiSPI() -> gpio_hold_dis() needed

			// Now that we have setup a wake cause and if needed setup the peripherals state in deep sleep,
			// we can now start going to deep sleep. In the case that no wake up sources were provided but
			// deep sleep was started, it will sleep forever unless hardware reset occurs.

//			esp_deep_sleep((uint64_t) waittime * uS_TO_S_FACTOR);	// start sleep with RTC time trigger: no return from here
			esp_sleep_enable_timer_wakeup((uint64_t) waittime * uS_TO_S_FACTOR);
			esp_deep_sleep_start();

			BHLOG(LOGBH) Serial.println("  Main: This should never be printed");	// restart with setup() instead
			break;

		case 2:		// LightSleepMode
			BHLOG(LOGBH) Serial.printf("  Main: Light Sleep - Trigger: Timer(%i sec.) + GPIO%d(blue Key1)\n", (uint32_t)waittime, EPD_KEY1);
			gpio_wakeup_enable(EPD_KEY1, GPIO_INTR_LOW_LEVEL);	// set GPIO of blue key1 button as trigger in low level
			esp_sleep_enable_gpio_wakeup();		// enable wakeup feature of selected GPIO wakeup resource

			// Configure the wake up timer source
			rc = esp_sleep_enable_timer_wakeup((uint64_t)waittime * uS_TO_S_FACTOR);	// time in us
			if(rc != ESP_OK){
				BHLOG(LOGBH) Serial.printf("  Main: LightSleep timer setup failed: %i\n", rc);
			}else{
				//	delay(initdelay); 					// set gracetime for timer activation
			}

			rc = esp_light_sleep_start();
			if(rc != ESP_OK){
				BHLOG(LOGBH) Serial.printf("  Main: LightSleep failed: %i\n", rc);
				delay(5000);	// wait some time to show the message
				// ToDo: what to do i this error case ???
			}

			BHLOG(LOGBH) Serial.println("  Main: Continue from LightSleep...");
			break;

		case 3:		// ModemSleepMode
			// ESP32 can enter modem sleep mode only when it connects to the router in station mode.
			// ESP32 stays connected to the router through the DTIM beacon mechanism
			// NOP
			break;

		case 4:		// Active Mode
			// NOP
			break;

		default:
#ifndef BEACON
	    	BHLOG(LOGBH) Serial.printf("  Loop: Enter WaitLoop (%i sec.)\n", report_interval);
#endif
			mydelay(waittime*1000);   // time in ms - wait with blinking red LED
			BHLOG(LOGBH) Serial.println();
			break;
	} // switch

}


//***********************************************************************
/// @brief Method to print the reason by which ESP32
/// has been awaken from sleep
/// @param none
/// @return esp_sleep_wakeup_cause_t wakeup_reason
//***********************************************************************
esp_sleep_wakeup_cause_t print_wakeup_reason(){
	esp_sleep_wakeup_cause_t wakeup_reason;

	wakeup_reason = esp_sleep_get_wakeup_cause();

	switch(wakeup_reason)  {
		case ESP_SLEEP_WAKEUP_EXT0:
				BHLOG(LOGBH)Serial.println("Wakeup caused by external signal using RTC_IO");
				EPDupdate=true;		// Update EPD by Key reboot request
				break;
		case ESP_SLEEP_WAKEUP_EXT1:
		       	BHLOG(LOGBH)Serial.println("Wakeup caused by external signal using RTC_CNTL");
				EPDupdate=true;		// Update EPD by Key reboot request
				break;
		case ESP_SLEEP_WAKEUP_TIMER:
		      	BHLOG(LOGBH)Serial.println("Wakeup caused by timer");
				EPDupdate=true;		// Update EPD by Key reboot request
//				EPDupdate=false;	// No Update of EPD requeste after timer reboot
				break;
		case ESP_SLEEP_WAKEUP_TOUCHPAD:
		   		BHLOG(LOGBH)Serial.println("Wakeup caused by touchpad");
				EPDupdate=true;		// Update EPD by Key reboot request
				break;
		case ESP_SLEEP_WAKEUP_ULP:
		        BHLOG(LOGBH)Serial.println("Wakeup caused by ULP program");
				EPDupdate=false;	// No Update of EPD requeste after timer reboot
				break;
		case ESP_SLEEP_WAKEUP_GPIO:
		       	BHLOG(LOGBH)Serial.println("Wakeup caused by GPIO");
				EPDupdate=true;		// Update EPD by Key reboot request
				break;
		case ESP_SLEEP_WAKEUP_UART:
		       	BHLOG(LOGBH)Serial.println("Wakeup caused by UART (light sleep only)");
				EPDupdate=false;	// No Update of EPD requeste after timer reboot
				break;
		case ESP_SLEEP_WAKEUP_ALL:
		        BHLOG(LOGBH)Serial.println("Not a wakeup cause: used to disable all wakeup sources with esp_sleep_disable_wakeup_source");
				EPDupdate=false;	// No Update of EPD requeste after timer reboot
				break;
		case ESP_SLEEP_WAKEUP_UNDEFINED:
				BHLOG(LOGBH)Serial.println("Reset or unknown WakeUp cause");
				EPDupdate=true;		// Update EPD by Key reboot request
				break;
		default :
				BHLOG(LOGBH)Serial.printf("Sleep>Wakeup root cause: %d unknown\n",wakeup_reason);
				EPDupdate=true;		// Update EPD
				wakeup_reason = ESP_SLEEP_WAKEUP_UNDEFINED;
	}
	return(wakeup_reason);
}


//*******************************************************************
// getChipRevision()
/// @brief Read eFuse bitfield block 3 and extract chip identification IDs
/// Global used:
///  bhdb.BoardID  unique Identifier (=MAC) of MCU board (use only lower 6By. (of8)
///  bhdb.Chipid   get chiptype: 0=WROOM32, 1=WROVER-B, ...
///  bhdb.ChipType get chip board type and revision -> relevant for sytem API vaildation
/// @param none
/// @return Chip ID from eFUse bitfield block 3
//*******************************************************************
int getChipRevision(){
#ifdef CONFIG_IDF_TARGET_ESP32
  return ((REG_READ(EFUSE_BLK0_RDATA3_REG) >> (EFUSE_RD_CHIP_VER_REV1_S)) & EFUSE_RD_CHIP_VER_REV1_V);
#else
	return(0);
#endif
}

//*******************************************************************
/// @brief Read eFuse bitfiels block 3 and extract chipt ID package version
/// @return ChipIdPkgVer - chip ID package version
//*******************************************************************
int getChipVerPkg(){
#ifdef CONFIG_IDF_TARGET_ESP32
  //  Serial.print(REG_READ(EFUSE_BLK0_RDATA3_REG),BIN);
  return ((REG_READ(EFUSE_BLK0_RDATA3_REG) >> (EFUSE_RD_CHIP_VER_PKG_S)) & EFUSE_RD_CHIP_VER_PKG_V);
#else
	return(0);
#endif
}

//*******************************************************************
/// @brief Read eFuse bitfiels block 3 using ESP.getEfuseMAC() and
/// print formatted values as one line
/// @param	global: update bhdb-struct by detected values of eFUse field
/// @return version
//*******************************************************************
void get_efuse_ident(void) {

	bhdb.BoardID = ESP.getEfuseMac();//The chip ID is essentially its MAC address(length: 6 bytes).
	Serial.printf("  Setup: ESP32 BoardID = %04X",(uint16_t)(bhdb.BoardID>>32)); //print High 2 bytes
	Serial.printf("%08X\n",(uint32_t)bhdb.BoardID);  //print Low 4bytes.

#ifdef CONFIG_IDF_TARGET_ESP32
	esp_chip_info(&bhdb.chipTYPE);
	Serial.printf("  Setup: Detected ESP32-S-Model:%d, Rev: %i ", bhdb.chipTYPE.model, bhdb.chipTYPE.revision);
	Serial.printf("  %s\n", esp_get_idf_version());
	Serial.printf("  Setup: Chip Revision: %d -", getChipRevision());

	bhdb.chipID = getChipVerPkg();
  	Serial.printf("-  Chip-Package ID: %d  ", bhdb.chipID);

  switch(bhdb.chipID){
		case EFUSE_RD_CHIP_VER_PKG_ESP32D0WDQ6:	Serial.println("-> ESP32D0WDQ6 (WROOM32)"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32D0WDQ5:	Serial.println("-> ESP32D0WDQ5 (WROVER-B)"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32D2WDQ5:	Serial.println("-> ESP32D2WDQ5"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32PICOD2:	Serial.println("-> ESP32PICOD2"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32PICOD4:	Serial.println("-> ESP32PICOD4"); break;
		default: 	Serial.println("-> unknown"); break;
	}
#endif
  //	Serial.println(esp_efuse_get_pkg_ver(), BIN);
}


//*******************************************************************
/// @brief Reset Node
/// @brief - Reset statistic counter
/// @brief - clear SD
/// @brief - initiate JOIN for new cfg. data
/// @return void	But GW expects JOIN request  on defjoin channel
//*******************************************************************
void ResetNode(uint8_t level, uint8_t sdlevel, uint8_t p3){
	// Reset SD Card: P1=1: LogFile, P1=2: Directory
	sd_reset(sdlevel);
	ESP.restart();	// Reset ESP /wo Reentry reason
}


//*******************************************************************
/// @brief bat_control()  Battery Charging Control by BATT - VoltLevel
/// @brief 1. Initialize Battery Statemachine (init=1)
/// @brief 2. Evaluate Bat Charge enable/disable (init=0) by Battery level and status
/// @brief 3. Report Warning/Error Message via LoRa pkg if BAT-Damaged
/// @return =0	Battery is o.k. => level in range of load/charge control
/// @return =1  Battery is damaged (not charging / out of range)
//*******************************************************************
// start battery charging
void Enable_bat_charge(void){

	pinMode(BATCHARGEPIN,  OUTPUT);
	digitalWrite(BATCHARGEPIN, LOW);	// switch Charge control On
	return;
}
// stop charging -> battery just serves the load
void Disable_bat_charge (void){
//	pinMode(BATCHARGEPIN, INPUT);		// better set it to High Impedance -> good for sleep mode

	pinMode(BATCHARGEPIN,  OUTPUT);
	digitalWrite(BATCHARGEPIN, HIGH);	// need to stay high in sleep mode as well.
	return;
}


int bat_control(float batlevel, bool bootinit){
int rc=0;
int cnum=0;

	gpio_hold_dis(BATCHARGEPIN);		// Release Pin from RTC control

	if(bootinit){						// called by setup phase -> ignore battlevel by now
		bat_status = BAT_UNKNOWN;		// have to wait for first Bat.Level.Value
		// Enter Reset-default mode: Charge Control On	( if not already there)
		pinMode(BATCHARGEPIN, INPUT);	// to High Impedance
		return(rc);
	}

	switch(bat_status){
	case(BAT_UNCHARGE):		// in Discharging phase
		if( batlevel <= BATTERY_MIN_LEVEL ){	// Emergency case: No Load Power of batter damaged ?!
			bat_status = BAT_DAMAGED;
			Enable_bat_charge();		// but lets hope power comes back
			BHLOG(LOGBH) Serial.println("    BAT-DAMAGED State entered");
			// Send a BAT Damage note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "BatBAD!");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
			rc=1;
		}else if( batlevel <= BATCHRGSTART ){ // lower threshold reached for restart charging phase ?
			bat_status = BAT_CHARGING;
			Enable_bat_charge();
			BHLOG(LOGBH) Serial.println("    BAT-CHARGE State entered");
			// Send a BAT Charge note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "Charging");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
			rc=0;
		}else{
		// else: simply remain in Un charging phase
			Disable_bat_charge();
			BHLOG(LOGBH) Serial.println("    BAT-UNCHARGING State");
		}
		break;
	case(BAT_CHARGING):
		if( batlevel >= BATTERY_MAX_LEVEL ){
			if(bhdb.dlog.BattFullCnt++ > BATTMAXCNT){
				// battery charging completed -> we can stop charging
				bat_status = BAT_UNCHARGE;
				Disable_bat_charge();
				BHLOG(LOGBH) Serial.printf("    BAT Full -> UNCHARGING State entered: %i\n", bhdb.dlog.BattFullCnt);
				// Send a BAT Full note via LoRa message for service
				cnum=sprintf(bhdb.dlog.comment, "BatFull");
				if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
				bhdb.dlog.BattFullCnt = 0;
			}else{
				// Assure resilient charge state, lets remain in charging phase a bit longer
				BHLOG(LOGBH) Serial.println("    BAT-CHARGE State");
				Enable_bat_charge();
				rc=0;
			}
		}else if( batlevel < BATTERY_SHUTDOWN_LEVEL ){
			// Emergency case: No Load Power or batter damaged ?!
			bat_status = BAT_DAMAGED;
			Enable_bat_charge();			// but lets hope power comes back once
			BHLOG(LOGBH) Serial.println("    BAT-DAMAGED State entered");
			// Send a BAT Damage note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "BatBAD!");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
			rc=1;
		}else{
			// else: All o.k., lets remain in charging phase
			BHLOG(LOGBH) Serial.println("    BAT-CHARGE State");
			Enable_bat_charge();
			rc=0;
		}
		break;

	case(BAT_UNKNOWN):
		if( batlevel > BATTERY_NORM_LEVEL ){
			bat_status = BAT_UNCHARGE;
			Disable_bat_charge();
			BHLOG(LOGBH) Serial.printf("    BAT-UNCHARGING State entered (%.2fV)\n", batlevel/1000);
			// Send a BAT Good note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "NoCharge");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
		}else if( batlevel < BATTERY_SHUTDOWN_LEVEL ){
			// Emergency case: No Load Power or batter damaged ?!
			bat_status = BAT_DAMAGED;
			Enable_bat_charge();			// but lets hope power comes back once
			BHLOG(LOGBH) Serial.printf("    BAT-DAMAGED State entered (%.2fV)\n", batlevel/1000);
			// Send a BAT Bad Warning note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "BatBAD!");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
			rc=1;
		}else{
			bat_status = BAT_CHARGING;
			Enable_bat_charge();
			BHLOG(LOGBH) Serial.printf("    BAT-CHARGE State entered (%.2fV)\n", batlevel/1000);
			// Send a BAT Charge note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "Charging");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
		}
		rc=0;
		break;

	case(BAT_DAMAGED): // or also BAT_LOW
		// do nothing: but wait till power comes back...

		if( batlevel <= BATTERY_SHUTDOWN_LEVEL ){	// Emergency case: No Load Power of batter damaged !!!
			report_interval = 3*10*60;	// set sleep time [sec] to very long: 1Hr -> save the LiPo battery
			BHLOG(LOGBH) Serial.printf("    BAT-DAMAGED State; throttled reporting (%i Min)/n", report_interval/60);
			Enable_bat_charge();		// but lets hope power comes back
			// Send a BAT Damage note via LoRa message for service
   			cnum=sprintf(bhdb.dlog.comment, "BattBAD!");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
			rc=1;

		}else if( batlevel > BATTERY_MIN_LEVEL ){	// seems Battery is charging again
			report_interval = 10*60;	// set Report. Interval to default [sec.]-> update at next JOIN
			BHLOG(LOGBH) Serial.printf("    Battery recovered -> Continue with CHARGING State (reporting %i Min.)\n", report_interval/60);
			bat_status = BAT_CHARGING;	// bring battery back to normal mode
			Enable_bat_charge();		// but lets hope power comes back
			// Send a BAT Charge note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "Charging");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
			rc=0;

		}else{ 							// we are still in <= BATTERY_MIN_LEVEL
			report_interval = 3*10*60;	// set sleep time [sec] to 1/2 hour -> save power
			BHLOG(LOGBH) Serial.printf("    BAT-LOW State entered; throttled reporting (%i Min)\n", report_interval/60);
			Enable_bat_charge();		// but lets hope power comes back
			rc=1;
			// Send a BAT Low warning note via LoRa message for service
	    	cnum=sprintf(bhdb.dlog.comment, "BattLow!");
			if(cnum>0)	bhdb.dlog.comment[cnum+1]=0;	// add ending '0'
		}
		break;

	default:
		rc=0;
		BHLOG(LOGBH) Serial.println("BAT-DEFAULT -> should never happen!");
		break;
	} // end of Switch

	return(rc);	// return battery state
}


void reset_RTCIO(void){
	// Reset all OUT Pins (to default HIGH = input)
	gpio_reset_pin(GPIO_NUM_0);
	gpio_reset_pin(GPIO_NUM_2);
	gpio_reset_pin(GPIO_NUM_5);
	gpio_reset_pin(GPIO_NUM_6);
	gpio_reset_pin(GPIO_NUM_7);
	gpio_reset_pin(GPIO_NUM_8);
	gpio_reset_pin(GPIO_NUM_9);
	gpio_reset_pin(GPIO_NUM_10);
	gpio_reset_pin(GPIO_NUM_11);
	gpio_reset_pin(GPIO_NUM_12);
	gpio_reset_pin(GPIO_NUM_14);
	gpio_reset_pin(GPIO_NUM_15);
	gpio_reset_pin(GPIO_NUM_17);
	gpio_reset_pin(GPIO_NUM_21);
	gpio_reset_pin(GPIO_NUM_34);
	gpio_reset_pin(GPIO_NUM_36);
}

// end of BeeIoT main