//*******************************************************************
/// @file   MAIN.cpp
/// @brief  BeeIoT - Main Header file
/// @author MchResse
/// @date   2020-12-18
/// @details
// from Project https://github.com/mchresse/BeeIoT
//
// Description:
// Contains main setup() and loop() routines for esspressif32 platforms.
//
//----------------------------------------------------------
// Copyright (c) 2019-present, Randolph Esser
// All rights reserved.
// This file is distributed under the BSD-3-Clause License
// The complete license agreement can be obtained at:
//     https://github.com/mchresse/BeeIoT/license
// For used 3rd party open source see also Readme_OpenSource.txt
//*******************************************************************
//
// This Module contains code derived from
// - The "espressif/arduino-esp32/preferences" library,
//   distributed under the Apache License, Version 2.0
// - MQTT Library distributed under the MIT-License:
//   https://opensource.org/licenses/mit-license.php
// -
//
//
//*******************************************************************
// BeeIoT Local Libraries
//*******************************************************************
// For ESP32-DevKitC PIN Configuration look at BeeIoT.h


#include <Arduino.h>
#include <stdio.h>
#include "sys/types.h"
#include <iostream>
#include <string>
// #include <esp_log.h>
// from Espressif Systems IDF: https://github.com/espressif/esp-idf/tree/71b4768df8091a6e6d6ad3b5c2f09a058f271348/components/log
#include "soc/efuse_reg.h"
#include <esp_efuse.h>

//#include "sdkconfig.h"   // generated from Arduino IDE
#include <Preferences.h> // from espressif-esp32 library @ GitHub
// see https://github.com/espressif/arduino-esp32/blob/master/libraries/Preferences/examples/StartCounter/StartCounter.ino

#include <driver/gpio.h>
#include <driver/rtc_io.h>
#include <esp_sleep.h>

#include "version.h"	// version file generated by buildscript_versioning.py script in project folder at build

// Libraries for SD card at ESP32_
// ...has support for FAT32 support with long filenames
#include <SPI.h>        // from Arduino IDE
#include <FS.h>         // from Arduino IDE
#include <SD.h>         // from Arduino IDE
#include "sdcard.h"

// Libs for WaveShare ePaper 2.7 inch r/w/b Pinning GxGDEW027C44
#include <GxEPD.h>                      // from ZinggJM/GxEPD (https://github.com/ZinggJM/GxEPD)
// #include <GxGDEW027C44/GxGDEW027C44.h> // 2.7" b/w/r
#include <GxGDEW027W3/GxGDEW027W3.h>     // 2.7" b/w
#include "BitmapWaveShare.h"            // from WaveShare -> FreeWare

// FreeFonts from Adafruit_GFX          // from adafruit / Adafruit-GFX-Library  (BSD license)
#include <Fonts/FreeMonoBold9pt7b.h>
#include <Fonts/FreeMonoBold12pt7b.h>
//#include <Fonts/FreeMonoBold18pt7b.h>
//#include <Fonts/FreeMonoBold24pt7b.h>
//#include <Fonts/FreeSansBold24pt7b.h>

// DS18B20 libraries
#include <OneWire.h>            // from PaulStoffregen/OneWire library @ GitHub
#include <DallasTemperature.h>  // LGPL v2.1
#include "owbus.h"

// Espressif I2C Library
#include <driver/i2c.h>         // from esp-idf/components/driver/I2C.h library @ GitHub
#include "i2cdev.h"				// I2C master Port setup

// Libraries for WIFI & to get time from NTP Server
#include <WiFi.h>               // from espressif-esp32 library @ GitHub
#include "wificfg.h"            // local
#include "esp_wifi.h"
#include "RTClib.h"             // from by JeeLabs adafruit /RTClib library @ GitHub

// include TCP Client library
#include "TCPClient.h"          // local

// include MQTT Client library
#include <MQTTClient.h>         // local

// Library fo HX711 Access
#include <HX711.h>              // HX711 library for Arduino (https://github.com/bogde/HX711)
#include "HX711Scale.h"         // local

#include <LoRa.h>       // Lora Lib from SanDeep (https://github.com/sandeepmistry/arduino-LoRa)
#include "BeeIoTWan.h"
#include "beelora.h"            // local: Lora Radio settings and BeeIoT WAN protocol definitions
#include "beeiot.h"             // local: provides all GPIO PIN configurations of all sensor Ports !

//************************************
// Global data object declarations
//************************************

#define LOOPTIME    60		// [sec] Loop wait time: 60 for 1 Minute
#define SLEEPTIME   60		// RTC sleep time in seconds
#ifdef BEACON
#define SLEEPMODE	  BEACONSLEEP  // =0 initial startup needed(after reset); =1 after deep sleep;
								   // =2 after light sleep; =3 ModemSleep Mode; =4 Active Wait Loop
#else
#define SLEEPMODE	  1 		// =0 initial startup needed(after reset); =1 after deep sleep; =2 after light sleep;
							    // =3 ModemSleep Mode; =4 Active Wait Loop
#endif

// WakeUp Source control
bool GetData = 0;				// =1 manual trigger by ISR (blue key) to start next measurement
RTC_DATA_ATTR int ReEntry = 0;	// =0 initial startup needed(after reset);   =1 after deep sleep;
								// =2 after light sleep; =3 ModemSleep Mode; =4 Active Wait Loop
RTC_DATA_ATTR int bootCount = 0;    // Deep Sleep Boot Counter

// Define deep sleep options
uint64_t uS_TO_S_FACTOR = 1000000;  // Conversion factor for micro seconds to seconds
int TIME_TO_SLEEP	= SLEEPTIME;	// RTC sleep in seconds

// Central Database of all measured values and runtime parameters
RTC_DATA_ATTR dataset		bhdb;
RTC_DATA_ATTR unsigned int	lflags; // BeeIoT log flag field
Preferences preferences;        // we must generate this object of the preference library

extern int iswifi;              // =1 WIFI flag o.k.
extern int isi2c;				// =1 I2C Master Port initialized
extern int isrtc;               // =1 RTC device discovered and time read
extern int isadc;				// >0 => Addr of I2C ADC dev connected
extern int isntp;               // =1 bhdb has latest timestamp
extern int issdcard;            // =1 SDCard found flag o.k.
extern int isepd;               // =1 ePaper found
extern int islora;              // =1 LoRa client is active

extern GxEPD_Class  display;    // ePaper instance from MultiSPI Module
extern HX711        scale;      // managed in HX711Scale module
extern i2c_port_t 	i2c_master_port;	// I2C Master Port in i2cdev.cpp
extern int 			adcaddr;	// I2C Dev.address of detected ADC

// LoRa protocol frequence parameter
long lastSendTime = 0;			// last send time
RTC_DATA_ATTR int  report_interval = LOOPTIME; // initial interval between BIoT Reports; can be overwritten by CONFIG
char LoRaBuffer[256];			// buffer for LoRa Packages

// construct the object attTCPClient of class TCPClient
TCPClient attTCPClient = TCPClient();


// construct the instance attMQTTClient of class MQTTClient -> not used yet
MQTTClient attMQTTClient = MQTTClient();
byte MQTTClient_Connected;
byte CounterForMQTT;

// 8 configuration values max managed by webpage  -> not used yet
#define CONFIGSETS    8
String ConfigName[CONFIGSETS];     // name of the configuration value
String ConfigValue[CONFIGSETS];    // the value itself (String)
int    ConfigStatus[CONFIGSETS];   // status of the value    0 = not set    1 = valid   -1 = not valid
int    ConfigType[CONFIGSETS];     // type of the value    0 = not set    1 = String (textbox)   2 = Byte (slider)

extern String WebRequestHostAddress;     // global variable used to store Server IP-Address of HTTP-Request
extern byte   RouterNetworkDeviceState;

//************************************
// Global function declarations
//************************************
void showFont(const char name[], const GFXfont* f);
void showFontCallback(void);
void showPartialUpdate(float data);
void ProcessAndValidateConfigValues(int countValues);
void InitConfig(int mode);
void prepare_sleep_mode(int mode, int sleeptime);
esp_sleep_wakeup_cause_t print_wakeup_reason();
void CheckWebPage();
void BeeIoTSleep(void);
void biot_ioshutdown(int sleepmode);
void get_efuse_ident(void);
void wiretest();


//*******************************************************************
/// @brief BeeIoT Setup Routine - Probe for all expected IO/Sensor devices
/// Detect and check functionality incl. test output where applicable
/// IO ports will be enabled depending on the wakeup mode.
/// @param none
/// @return void
//*******************************************************************
void setup() {
int rc;		// generic return code variable
  // put your setup code here, to run once:
	pinMode(LED_RED,   OUTPUT);
	digitalWrite(LED_RED, LOW); // signal Setup Phase
	gpio_hold_dis(LED_RED);   	// enable SD_CS
	pinMode(EPD_CS, OUTPUT);    //VSPI SS for ePaper EPD
    pinMode(SD_CS,  OUTPUT);    //HSPI SS for SDCard Port
    pinMode(BEE_CS, OUTPUT);
    digitalWrite(EPD_CS, HIGH);
    digitalWrite(SD_CS, HIGH);
    digitalWrite(BEE_CS, HIGH);
    gpio_hold_dis(SD_CS);   	// enable SD_CS
    gpio_hold_dis(EPD_CS);   	// enable EPD_CS
    gpio_hold_dis(BEE_CS);  	// enable BEE_CS

	delay(500); //delay nicht entfernen wg Wakeup mode !

  // If Ser. Diagnostic Port connected
	while(!Serial);             // wait to connect to computer
	Serial.begin(115200);       // enable Ser. Monitor Baud rate
	//	delay(500);					// wait for console init

 //  wiretest();                // for HW incompatibility tests og GPIOs

//***************************************************************
  //Print the wakeup reason for ESP32
  BHLOG(LOGBH)Serial.printf("Evaluate Wakeup reason - BootCnt: %i - Intervall %i\n", bootCount, report_interval);
	rc = print_wakeup_reason();
	if(rc != ESP_SLEEP_WAKEUP_UNDEFINED){ // DeepSleep WakeUp Reason
      //  		BHLOG(LOGBH)Serial.printf("Main: DeepSleep Wakup (%i)\n", rc);
  		if(rc == ESP_SLEEP_WAKEUP_TIMER){
			// increment WakeUp boot counter and check if loop wait time reached -> if not: sleep again
			if(++bootCount < (report_interval/TIME_TO_SLEEP)){  // needed in case looptime exceed std. sleep time
				// Start deep sleep again -> split in chunks of sleep windows
        // if deep sleep time == report_interval no boot counter needed:
        //				prepare_sleep_mode(ReEntry, report_interval);
			}
		}else if(rc == ESP_SLEEP_WAKEUP_GPIO){
			// GPIO shortcuts sleep wait loop: Just continue with shortcut setup phase
  			BHLOG(LOGBH)Serial.printf("Main: Sleep Wakup by GPIO (%i)\n", rc);
  		}
	} else {
	  ReEntry = 0;	// reset was pressed
	}

  // ReEntry mode was defined at start of sleep mode already
	// wakeup by Reset -> start initial setup code and reset counter anyway
	bootCount = 0;

//***************************************************************
	if(!ReEntry) {
    // Define Log level (search for Log values in beeiot.h)
    // lflags = LOGBH + LOGOW + LOGHX + LOGLAN + LOGEPD + LOGSD + LOGADS + LOGSPI + LOGLORAR + LOGLORAW;
		lflags = LOGBH + LOGLORAW + LOGSD;
//	lflags = 65535;
	// works only in setup phase till LoRa-JOIN received Cfg data
	// final value will be defined in BeeIoTParseCfg() by GW config data

		Serial.println();
		Serial.println(">***********************************<");
		Serial.printf (">   BeeIoT - BeeHive Weight Scale\n");
		Serial.printf ("> %s by R.Esser (c) 11/2020\n", VERSION_SHORT);
		Serial.println(">***********************************<");
		if(lflags > 0)
			Serial.printf ("LogLevel: %i\n", lflags);
		BHLOG(LOGBH)Serial.println("Start Sensor Setup Phase ...");

		//***************************************************************
		// get bhdb.BoardID (=WiFI MAC), .ChipID and .ChipREV from eFuse area
		get_efuse_ident();
	}

//***************************************************************
// Preset BeeIoT runtime config values
  BHLOG(LOGBH) Serial.println("  Setup: Init runtime config settings");
  InitConfig(ReEntry);

//***************************************************************
// I2C_master() has to be started always before setup_rtc() and setup_i2c_ADC/MAX()
  BHLOG(LOGBH) Serial.println("  Setup: I2C Master Device Port Init/Scan");
  isi2c = setup_i2c_master(ReEntry);
  if (!isi2c){
    BHLOG(LOGBH) Serial.println("  Setup: I2c Master port failed ");
    // enter here exit code, if needed
  }

//***************************************************************

  BHLOG(LOGBH) Serial.println("  Setup: Init RTC Module DS3231 ");
  if (!setup_rtc(ReEntry)){
    BHLOG(LOGBH) Serial.printf("  Setup: RTC setup failed\n");
    // enter exit code here, if needed (monitoring is hard without correct timestamp)
    // isrtc should be 0 here; hopefully NTP can help out later on
  }else{
    BHLOG(LOGLAN) rtc_test();
    getRTCtime();
  }


//***************************************************************
  BHLOG(LOGBH) Serial.println("  Setup: SPI Devices");
  issdcard = setup_spi_VSPI(ReEntry);
  if (!issdcard){
    BHLOG(LOGBH) Serial.println("  Setup: SPI SD setup failed.");
    // enter here exit code, if needed
  }

//***************************************************************
  BHLOG(LOGBH) Serial.println("  Setup: HX711 Weight Cell");
  if (!setup_hx711Scale(ReEntry)){
    BHLOG(LOGBH) Serial.println("  Setup: HX711 Weight Cell setup failed");
    // enter here exit code, if needed
  }

//***************************************************************
if(isadc){	// I2C Master Port active + ADC detected ?
// only one ADC dev. type accepted -> as set by adcaddr in i2c_scan()
  	BHLOG(LOGBH) Serial.println("  Setup: ADC ADS11x5");
	if (!setup_i2c_ADS(ReEntry)){
    	BHLOG(LOGBH) Serial.println("  Setup: ADS11x5 setup failed");
    	// enter here exit code, if needed
	}
	//***************************************************************
	BHLOG(LOGBH) Serial.println("  Setup: ADC MAX123x");
	if (!setup_i2c_MAX(ReEntry)){  // MAX123x constructor
  		BHLOG(LOGBH) Serial.println("  Setup: MAX123x setup failed");
   		// enter here exit code, if needed
	}
}


//***************************************************************
// setup Wifi & NTP & RTC time & Web service
  BHLOG(LOGBH) Serial.println("  Setup: Wifi in Station Mode");
  if (!setup_wifi(ReEntry)){
    BHLOG(LOGBH) Serial.println("  Setup: Wifi setup failed -> No NTP");
    // enter here exit code, if needed
    // probably we are LOOPTIME ahead ?!
    // recalc bhdb "timestamp+LOOPTIME"  here
  }else{  // WIFI connected
    if (!setup_ntp(ReEntry)){
      BHLOG(LOGBH) Serial.println("  Setup: NTP setup failed");
      isntp = 0;
      // enter exit code here, if needed
      // NTP requires connected WIFI ! -> check iswifi also
    }else{
      BHLOG(LOGLAN) Serial.println("  Setup: Get new Date & Time:");
      rc = ntp2rtc();
	  if(rc <0){       // init RTC time once at restart
      	BHLOG(LOGLAN) Serial.printf("  ntp2rtc fails (%i)", rc);
	  }
    }

// start the webserver to listen for request of clients (in LAN or own ESP32 network)
//    BHLOG(LOGBH) Serial.println("  Setup: Start Webserver");
//    Webserver_Start();
  }

  getTimeStamp();  // get curr. time either by NTP or RTC -> update bhdb

//***************************************************************
  BHLOG(LOGBH) Serial.println("  Setup: SD Card");
  if(issdcard){
    if (!setup_sd(ReEntry)){
      BHLOG(LOGBH) Serial.println("  SD: SD Card failed");
      // enter exit code here, if needed
    }
  }

//***************************************************************
  BHLOG(LOGBH) Serial.println("  Setup: LoRa SPI device & Base layer");
  if (!setup_LoRa(ReEntry)){
    BHLOG(LOGBH) Serial.println("  Setup: LoRa Base layer setup failed");
    // enter exit code here, if needed
  }


//***************************************************************
  BHLOG(LOGBH) Serial.println("  Setup: OneWire Bus setup");
  if (setup_owbus(ReEntry) == 0){
    BHLOG(LOGBH) Serial.println("  Setup: No OneWire devices found");
    // enter exit code here, if needed
  }else{
    GetOWsensor(0); // read temperature the first time
  }
//***************************************************************
  BHLOG(LOGBH)Serial.println("  Setup: ePaper + show start frame ");
  if (!setup_epd(ReEntry)){
    BHLOG(LOGBH)Serial.println("  Setup: ePaper Test failed");
    // enter exit code here, if needed
  }

//***************************************************************
  BHLOG(LOGBH) Serial.println("Setup Phase done");
  Serial.println(" ");

// while(1);  // for setup test purpose

} // end of BeeIoT setup()



//*******************************************************************
/// @brief  BeeIoT Main Routine: Loop() as endless loop
/// @param none
//*******************************************************************
void loop() {

  digitalWrite(LED_RED, HIGH);  // show start of new loop() phase
//***************************************************************
// get current time to bhdb
  if(getTimeStamp() == -2){   // no valid time source found
    strncpy(bhdb.dlog[bhdb.loopid].timeStamp, "0000-00-00 00:00:00", LENTMSTAMP);
  }else{
    // store curr. timstamp for next data row
    sprintf(bhdb.dlog[bhdb.loopid].timeStamp, "%s %s", bhdb.date, bhdb.time);
  }

  BHLOG(LOGBH) Serial.println(">***********************************************<");
  BHLOG(LOGBH) Serial.println("> Start next BeeIoT Weight Scale loop");
  BHLOG(LOGBH) Serial.printf ("> Loop# %i  (Laps: %i, BHDB[%i]) %s\n",
		bhdb.loopid + (bhdb.laps*datasetsize), bhdb.laps, bhdb.loopid, bhdb.dlog[bhdb.loopid].timeStamp);
  BHLOG(LOGBH) Serial.println(">***********************************************<");

  bhdb.dlog[bhdb.loopid].index = bhdb.loopid + (bhdb.laps*datasetsize);
  strncpy(bhdb.dlog[bhdb.loopid].comment, "o.k.", 5);


//***************************************************************
// Check for Web Config page update
#ifdef WIFI_CONFIG
  if(iswifi == 0){
//      BHLOG(LOGLAN) Serial.println("  Loop: Check for new WebPage Client request...");
//      CheckWebPage();
  }
#endif // WIFI_CONFIG

//
//***************************************************************
// get Weight Scale values
#ifdef HX711_CONFIG
  float weight;
  scale.power_up();  // HX711 WakeUp Device

  // Acquire raw reading
  weight = HX711_read(0);
  BHLOG(LOGHX) Serial.printf("  Loop: Weight(raw) : %d", (u_int) weight);

  // Acquire unit reading
  weight = HX711_read(1);
  BHLOG(LOGHX) Serial.printf(" - Weight(unit): %.3f kg\n", weight);
  bhdb.dlog[bhdb.loopid].HiveWeight = weight;

  scale.power_down();
#endif // HX711_CONFIG

//***************************************************************
// Scan OW Temp. Sensors
#ifdef ONEWIRE_CONFIG
  setup_owbus(0);
  GetOWsensor(bhdb.loopid);   // Get all temp values directly into bhdb

  while(bhdb.dlog[bhdb.loopid].TempHive > 70){  // if we have just started lets do it again to get right values
    GetOWsensor(bhdb.loopid);                   // Get all temp values directly into bhdb
    delay(100);
  }
#endif // ONEWIRE_CONFIG

//***************************************************************
// Monitor Analog Ports: e.g. of battery Control
#ifdef ADS_CONFIG
uint32_t addata = 0;   	// raw ADS Data buffer

float x;              		// Volt calculation buffer

  // read out all ADS channels 0..3
  BHLOG(LOGADS) Serial.print("  Loop: ADSPort(0-3): ");

  addata = (uint32_t)adc_read(0) * 306 / 100;  		// get Level of Battery Charge Input from Ext-USB port
  bhdb.dlog[bhdb.loopid].BattCharge = addata; //  measured: 5V/3,3 = 1,63V value (Dev-R: 33k / 69k)
  BHLOG(LOGADS) Serial.print((float)addata/1000, 2);
  BHLOG(LOGADS) Serial.print("V - ");

  addata = (uint32_t)adc_read(1) * 2;         			// get 3.3V line value of ESP32 devKit in mV
  bhdb.dlog[bhdb.loopid].ESP3V = (uint16_t) addata;	// AIN1 has 2x33k -> div by 2
  BHLOG(LOGADS) Serial.print((float)addata/1000, 2);
  BHLOG(LOGADS) Serial.print("V - ");

  // addata = adc_read(2);
	addata = (uint32_t) 0;				// not connected
  bhdb.dlog[bhdb.loopid].Board5V = (uint16_t) addata;		// value is useless
  BHLOG(LOGADS) Serial.print((float)addata/1000, 2);
  BHLOG(LOGADS) Serial.println("V");

  addata = (uint32_t)adc_read(3) * 3;         			// Get Battery raw Capacity in Volt ((10%) 3.7V - 4.2V(100%))
  // calculate Battery Load Level in %
  x = ((float)(addata-BATTERY_MIN_LEVEL)/		//  measured: Vbatt/3 = 1,20V value (Dev-R: 33k / 69k)
       (float)(BATTERY_MAX_LEVEL-BATTERY_MIN_LEVEL) )* 100;
  bhdb.dlog[bhdb.loopid].BattLevel = (int16_t) x;
  bhdb.dlog[bhdb.loopid].BattLoad = (uint16_t) addata;
  BHLOG(LOGADS) Serial.printf("%.2fV (%i%%)", (float)addata/1000, bhdb.dlog[bhdb.loopid].BattLevel);
  BHLOG(LOGADS) Serial.print(" - ");

#endif // ADS_CONFIG


//***************************************************************
// save all collected sensor data to SD and/or report via LoRa/Wifi
	Logdata();

//***************************************************************
// Update ePaper
#ifdef EPD_CONFIG
    BHLOG(LOGEPD) Serial.println("  Loop: Show Sensor Data on EPD");
#ifdef BEACON
    showbeacon(bhdb.loopid);
#else
    showdata(bhdb.loopid);
#endif
#endif

//***************************************************************
// Calculate next loop Index
  digitalWrite(LED_RED, HIGH);	// show end of Loop phase
  bhdb.loopid++;     // Increment LoopID for next loop
  if (bhdb.loopid == datasetsize){  // Max. numbers of datarows filled ?
    bhdb.loopid = 0;  // reset datarow idx -> round robin buffer for 1 day only
    bhdb.laps++;      // remember how many times we had a bhdb bufferoverflow.
  }

//***************************************************************
// End of Main Loop ->  Save data and enter Sleep/Delay Mode
	ReEntry = SLEEPMODE;	// initial startup sleep mode;
					// =1 after deep sleep; =2 after light sleep; =3 ModemSleep Mode; =4 Active Wait Loop
  // Start sleep/wait loop
	prepare_sleep_mode(ReEntry, report_interval); // intervall in seconds

} // end of loop()



//*******************************************************************
/// @brief Logdata() Append current sensor data set to SD card -> logdata file
/// and send it via LoRaWAN
/// @param none
//*******************************************************************
void Logdata(void) {
uint16_t sample;
String dataMessage; // Global data objects

  sample = (bhdb.laps*datasetsize) + bhdb.loopid;

// Create tatus Report based on the sensor readings
  dataMessage =
              String(bhdb.date) + " " +
              String(bhdb.time) + "," +
              String(bhdb.dlog[bhdb.loopid].HiveWeight) + "," +
              String(bhdb.dlog[bhdb.loopid].TempExtern) + "," +
              String(bhdb.dlog[bhdb.loopid].TempIntern) + "," +
              String(bhdb.dlog[bhdb.loopid].TempHive)   + "," +
              String(bhdb.dlog[bhdb.loopid].TempRTC)    + "," +
              String((float)bhdb.dlog[bhdb.loopid].ESP3V/1000)      + "," +
              String((float)bhdb.dlog[bhdb.loopid].Board5V/1000)    + "," +
              String((float)bhdb.dlog[bhdb.loopid].BattCharge/1000) + "," +
              String((float)bhdb.dlog[bhdb.loopid].BattLoad/1000)   + "," +
              String(bhdb.dlog[bhdb.loopid].BattLevel)  + "#" +
              String(sample) + " " +
              String(bhdb.dlog[bhdb.loopid].comment) +
              "\r\n";       // OS common EOL: 0D0A

#ifndef BEACON
  Serial.printf("  Loop[%i]: ", sample);
  Serial.print(dataMessage);

  // Write the sensor readings onto the SD card
  if(issdcard){
    appendFile(SD, SDLOGPATH, dataMessage.c_str());
  }else{
    BHLOG(LOGSD) Serial.println("  Log: No SDCard, no local Logfile...");
  }
#endif

  // Send Sensor report via BeeIoT-LoRa ...
  if(islora){  // do we have an active connection (joined ?)
#ifdef BEACON
    // For Test purpose of transmission quality: send a beacon to the current GW
    BeeIoTBeacon(0);  // in Non-Joined Mode != BIOT_JOIN (assumed LoRa Log was successfull)
#else
    LoRaLog((char *) dataMessage.c_str(), (byte)dataMessage.length(), 0); // in sync mode
#endif
  }else{
    BHLOG(LOGLORAW) Serial.println("  Log: No LoRa, no BeeIoTWAN on air ...");
  }

  return;
}

void mydelay(int32_t tval){
  int fblink = tval / 1000;   // get # of seconds == blink frequence
  int i;
  for (i=0; i < fblink/2; i++){
    digitalWrite(LED_RED, LOW);
//      if(iswifi == 0){
//        CheckWebPage();
//      }
    delay(250);  // wait 0.25 second
    digitalWrite(LED_RED, HIGH);
//      if(iswifi == 0){
//        CheckWebPage();
//      }
    delay(2000);  // wait 2 second
	if(GetData){  // Semaphor controlled by GPIO35 Key (blue button)
		// user wants next measurement loop
		GetData = 0;	// reset loop trigger flag
		return;			// and start next measurement loop
	}
  } // loop
}

//*******************************************************************
/// @brief initialize static configuration settings of housekeeping data
/// @param reentry 0..4 wakeup mode
/// @details
///		=0 initial startup needed(after reset)
/// 	=1 after deep sleep /Ram destroyed, except RTC Mem)
/// 	=2 after light sleep (Ram up to date)
///		=3 ModemSleep Mode (not used)
///		=4 Active Wait Loop using delay()
/// @return void
//*******************************************************************
void InitConfig(int reentry){
  int i;

	if(!reentry){
		bhdb.loopid       = 0;
		bhdb.laps         = 0;
		bhdb.formattedDate[0] = 0;
		bhdb.date[0]      = 0;
		bhdb.time[0]      = 0;
		bhdb.ipaddr[0]    = 0;
		// bhdb.BoardID      = 0;  already defined
		for(i=0; i<datasetsize;i++){
			bhdb.dlog[i].index       =0;
			bhdb.dlog[i].HiveWeight  =0;
			bhdb.dlog[i].TempExtern  =0;
			bhdb.dlog[i].TempIntern  =0;
			bhdb.dlog[i].TempHive    =0;
			bhdb.dlog[i].TempRTC     =0;
			bhdb.dlog[i].timeStamp[0]=0;
			bhdb.dlog[i].ESP3V       =0;
			bhdb.dlog[i].Board5V     =0;
			bhdb.dlog[i].BattLevel   =0;
			bhdb.dlog[i].BattCharge  =0;
			bhdb.dlog[i].BattLoad    =0;
			strncpy(bhdb.dlog[i].comment, "OK", 3);
		}
	}

// Next settings are for Web based config Page:
// see https://github.com/espressif/arduino-esp32/blob/master/libraries/Preferences/examples/StartCounter/StartCounter.ino
  preferences.begin("MyJourney", false);

  // takeout 4 Strings out of the Non-volatile storage
  String strSSID        = preferences.getString("SSID", "");
  String strPassword    = preferences.getString("Password", "");
  String strDeviceID    = preferences.getString("DeviceID", "");
  String strDeviceToken = preferences.getString("DeviceToken", "");

  // reset all default config parameter sets
  for (int count = 0; count < CONFIGSETS; count++){
    ConfigName[count]   = "";
    ConfigValue[count]  = "";
    ConfigStatus[count] = 0;
    ConfigType[count]   = 0;
  }

  // initialize config set values and set names
  ConfigName[0] = "LED";
  ConfigType[0] = 1;     // type textbox

  ConfigName[1] = "SSID";
  ConfigType[1] = 1;

  ConfigName[2] = "PASSWORD";
  ConfigType[2] = 1;

  ConfigName[3] = "DEVICE ID";
  ConfigType[3] = 1;

  ConfigName[4] = "DEVICE TOKEN";
  ConfigType[4] = 1;

  // put the NVS stored values in RAM for the program
  ConfigValue[1] = strSSID;
  ConfigValue[2] = strPassword;
  ConfigValue[3] = strDeviceID;
  ConfigValue[4] = strDeviceToken;

  MQTTClient_Connected = false;
  CounterForMQTT = 0;

} // end of InitConfig()

//*******************************************************************
/// @brief check the ConfigValues and set ConfigStatus;
/// process 4 config sets for LAN permission settings
/// @param countValues Number of processed configsets
/// @return void
//*******************************************************************
void ProcessAndValidateConfigValues(int countValues){
  BHLOG(LOGLAN) Serial.printf("  Webserver: ProcessConfigValues(%i)\n", countValues);
  if (countValues > CONFIGSETS) {
    countValues = CONFIGSETS;
  }

  // store the second to fifth value in non-volatile storage
  if (countValues > 4){
    preferences.putString("SSID",        ConfigValue[1]);
    preferences.putString("Password",    ConfigValue[2]);
    preferences.putString("DeviceID",    ConfigValue[3]);
    preferences.putString("DeviceToken", ConfigValue[4]);
  }

  // in our application the first value must be "00" or "FF" (as text string)
  if ((ConfigValue[0].equals("00")) || (ConfigValue[0].equals("FF"))){
    ConfigStatus[0] = 1;    // Value is valid
    BHLOG(LOGLAN) Serial.printf("  Webserver: Processing command: %s\n", ConfigValue[0].c_str());
  }else{
    ConfigStatus[0] = -1;   // Value is not valid
    BHLOG(LOGLAN) Serial.printf("  Webserver: Wrong command: %s\n", ConfigValue[0].c_str());
  }

  // processing command from here:
  // first config value is used to switch LED ( = Actor)
  if (ConfigValue[0].equals("00")){
    digitalWrite(LED_RED, HIGH);
    // do something with actors: SwitchActor(ACTOR_OFF);
  } else if (ConfigValue[0].equals("FF")){
    digitalWrite(LED_RED, LOW);
    // do something other with actors: SwitchActor(ACTOR_ON);
  }


}


//*******************************************************************
/// @brief biot_ioshutdown()
/// disable all hi level IO protocol devices (e.g. SPI)
/// and prepare IO ports for sleep mode accordingly,
/// @param sleepmode	wakeup mode
/// @details 1 DeepSleep Mode; 2 LightSleep Mode; 3 ModemSleep; 4 Active wait loop
/// @return void
//*******************************************************************
void biot_ioshutdown(int sleepmode){
  if(sleepmode == 1){    // in deep sleep we have to stabilize CS+RST lines of SPI devices
    BHLOG(LOGSPI) Serial.println("  MAIN: shutdown IO devices");

    // backup any needed memory values at wakeup here
    //			esp_bluedroid_disable();
    //			esp_bt_controller_disable();

#ifdef WIFI_CONFIG
    if(iswifi){
	//	esp_wifi_stop();
  		WiFi.disconnect(true);
  		WiFi.mode(WIFI_OFF);
  	}
    iswifi = 0;
#endif
#ifdef NTP_CONFIG
    isntp = 0;
#endif

#ifdef SD_CONFIG
    if(issdcard){
      SD.end();   // unmount SD card
    }
    digitalWrite(SD_CS, HIGH);
    gpio_hold_en(SD_CS);      // SD_CS
    issdcard = 0;
#endif

#ifdef EPD_CONFIG
    if(isepd){
      display.powerDown();
    }
    digitalWrite(EPD_CS, HIGH);
    digitalWrite(EPD_RST, HIGH);
    gpio_hold_en(EPD_CS);     // EPD_CS
    isepd = 0;
#endif

#ifdef LORA_CONFIG
    if(islora){
      LoRa.end();     // set LORA Radio to sleep mode and disable SPI
    }
    digitalWrite(BEE_CS, HIGH);
    digitalWrite(BEE_RST, HIGH);
    gpio_hold_en(BEE_CS);     // BEE_CS
    gpio_hold_en(BEE_RST);    // BEE_RST
    islora = 0;
#endif

#ifdef HX711_CONFIG
    pinMode(HX711_DT, OUTPUT);
    pinMode(HX711_SCK, OUTPUT);
    digitalWrite(HX711_SCK, HIGH);
    digitalWrite(HX711_DT, HIGH);
    gpio_hold_en(HX711_SCK);  // HX711 SCK
    gpio_hold_en(HX711_DT);   // HX711 Data
#endif

#ifdef ADS_CONFIG
//	i2c_driver_delete(i2c_master_port);
    // Set all I2C lines to high impedance -> open collector bus
    pinMode(I2C_SCL, OUTPUT);
    pinMode(I2C_SDA, OUTPUT);
    digitalWrite(I2C_SCL, HIGH);
    digitalWrite(I2C_SDA, HIGH);
    pinMode(ADS_ALERT, OUTPUT);
    digitalWrite(ADS_ALERT, HIGH);
    gpio_hold_en((gpio_num_t) I2C_SCL);    // ADS_SCL
    gpio_hold_en((gpio_num_t) I2C_SDA);    // ADS_SDA
    gpio_hold_en((gpio_num_t) ADS_ALERT);  // ADS_Alert
#endif

#ifdef ONEWIRE_CONFIG
// Set OW line to high impedance -> open collector bus
     pinMode(ONE_WIRE_BUS, OUTPUT);
     digitalWrite(ONE_WIRE_BUS, HIGH);
     gpio_hold_en(ONE_WIRE_BUS); // OneWire Bus line
#endif

    pinMode(LED_RED, OUTPUT);
	digitalWrite(LED_RED, HIGH);    // signal Sleep Phase: LED OFf to save power
    gpio_hold_en(LED_RED); // OneWire Bus line

    gpio_deep_sleep_hold_en();  // freeze all settings from above during deep sleep time
    // reactivation after deep sleep in setup_spi_VSPI() -> gpio_hold_dis() needed
  } // end of sleepmode
} // biot_ioshutdown()


//***********************************************************************
/// @brief Method to print the reason by which ESP32
/// has been awaken from sleep
/// @param Mode	1=DeepSleep Mode; 2=LightSleep Mode;
/// 		3=ModemSleep;
/// 		4=Active wait loop sleeptime -> loop time - value in seconds
/// @param waittime sleep/wait time in seconds
/// @return void
//***********************************************************************
void prepare_sleep_mode(int mode, int waittime){
esp_err_t  rc;

	switch(mode){
		case 1:		// DeepSleepMode
			biot_ioshutdown(mode);          // disable all IO devices and their IO Ports.

			// Next we decide what all peripherals to shut down/keep on.
			//	By default, ESP32 will automatically power down the peripherals
			//	not needed by the wakeup source,
    		//  Details at the API docs
			//	http://esp-idf.readthedocs.io/en/latest/api-reference/system/deep_sleep.html

      		// Keep power domain enabled in deep sleep, if it is needed by one of the wakeup options.
      		// Otherwise power it down.
    		BHLOG(LOGBH) Serial.println("  Main: Configure all RTC Peripherals to be powered");
    		esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_AUTO);
    		gpio_pullup_en(EPD_KEY4);                  // use RTC_IO pullup on GPIO 35
    		gpio_pulldown_dis(EPD_KEY4);               // not use pulldown on GPIO 35
			esp_sleep_enable_ext0_wakeup(EPD_KEY4, 0);	// select GPIO35 (blue button) as Wakup Trigger on low level
    		BHLOG(LOGBH) Serial.printf("  Main: Going to Deep Sleep - Trigger: Timer(%i sec.) + GPIO%d(blue Key4)\n", waittime, EPD_KEY4);

			// Now that we have setup a wake cause and if needed setup the peripherals state in deep sleep,
			// we can now start going to deep sleep. In the case that no wake up sources were provided but
			// deep sleep was started, it will sleep forever unless hardware reset occurs.
			esp_deep_sleep(waittime * uS_TO_S_FACTOR);	// start sleep with RTC time trigger: no return from here

			BHLOG(LOGBH) Serial.println("  Main: This will never be printed");
			break;

		case 2:		// LightSleepMode
			BHLOG(LOGBH) Serial.printf("  Main: Going to Light Sleep now - Trigger: Timer(%i sec.) + GPIO%d(blue Key4)\n", waittime, EPD_KEY4);
			gpio_wakeup_enable(EPD_KEY4, GPIO_INTR_LOW_LEVEL);	// set GPIO35 (blue key4 button) as trigger in low level
			esp_sleep_enable_gpio_wakeup();

			// Configure the wake up timer source
			esp_sleep_enable_timer_wakeup(waittime * uS_TO_S_FACTOR);	// time in us

			rc = esp_light_sleep_start();
			if(rc != ESP_OK){
				BHLOG(LOGBH) Serial.printf("  Main: LightSleep failed: %i\n", rc);
				delay(5000);
			}

			BHLOG(LOGBH) Serial.println("  Main: Continue from LightSleep...");
			break;

		case 3:		// ModemSleepMode
			// ESP32 can enter modem sleep mode only when it connects to the router in station mode.
			// ESP32 stays connected to the router through the DTIM beacon mechanism
			// NOP

		case 4:		// Active Mode
			// NOP

		default:
#ifndef BEACON
	    	BHLOG(LOGBH) Serial.printf("  Loop: Enter WaitLoop (%i sec.)\n", report_interval);
#endif
			mydelay(waittime*1000);   // time in ms - wait with blinking red LED
			BHLOG(LOGBH) Serial.println();
			break;
	} // switch

}


//***********************************************************************
/// @brief Method to print the reason by which ESP32
/// has been awaken from sleep
/// @param none
/// @return esp_sleep_wakeup_cause_t wakeup_reason
//***********************************************************************
esp_sleep_wakeup_cause_t print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)  {
    case ESP_SLEEP_WAKEUP_EXT0:       Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1:       Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER:      Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD:   Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP:        Serial.println("Wakeup caused by ULP program"); break;
	case ESP_SLEEP_WAKEUP_GPIO:       Serial.println("Wakeup caused by GPIO"); break;
	case ESP_SLEEP_WAKEUP_UNDEFINED:  Serial.println("Reset or unknown WakeUp cause"); break;
    default :
        Serial.printf("Sleep>Wakeup root cause: %d\n",wakeup_reason);
		    return(ESP_SLEEP_WAKEUP_UNDEFINED);
		    break;
  }
	return(wakeup_reason);
}


//*******************************************************************
// getChipRevision()
/// @brief Read eFuse bitfield block 3 and extract chip identification IDs
/// Global used:
///  bhdb.BoardID  unique Identifier (=MAC) of MCU board (use only lower 6By. (of8)
///  bhdb.Chipid   get chiptype: 0=WROOM32, 1=WROVER-B, ...
///  bhdb.ChipType get chip board type and revision -> relevant for sytem API vaildation
/// @param none
/// @return Chip ID from eFUse bitfield block 3
//*******************************************************************
int getChipRevision(){
  return ((REG_READ(EFUSE_BLK0_RDATA3_REG) >> (EFUSE_RD_CHIP_VER_REV1_S)) & EFUSE_RD_CHIP_VER_REV1_V);
}

//*******************************************************************
/// @brief Read eFuse bitfiels block 3 and extract chipt ID package version
/// @return ChipIdPkgVer - chip ID package version
//*******************************************************************
int getChipVerPkg(){
  //  Serial.print(REG_READ(EFUSE_BLK0_RDATA3_REG),BIN);
  return ((REG_READ(EFUSE_BLK0_RDATA3_REG) >> (EFUSE_RD_CHIP_VER_PKG_S)) & EFUSE_RD_CHIP_VER_PKG_V);
}

//*******************************************************************
/// @brief Read eFuse bitfiels block 3 using ESP.getEfuseMAC() and
/// print formatted values as one line
/// @param	global: update bhdb-struct by detected values of eFUse field
/// @return version
//*******************************************************************
void get_efuse_ident(void) {

	bhdb.BoardID = ESP.getEfuseMac();//The chip ID is essentially its MAC address(length: 6 bytes).
	Serial.printf("  Setup: ESP32 BoardID = %04X",(uint16_t)(bhdb.BoardID>>32)); //print High 2 bytes
	Serial.printf("%08X\n",(uint32_t)bhdb.BoardID);  //print Low 4bytes.

	esp_chip_info(&bhdb.chipTYPE);
	Serial.printf("  Setup: Detected ESP32-S-Model:%d, Rev: %i ", bhdb.chipTYPE.model, bhdb.chipTYPE.revision);
	Serial.printf("  %s\n", esp_get_idf_version());
	Serial.printf("  Setup: Chip Revision: %d -", getChipRevision());

	bhdb.chipID = getChipVerPkg();
  Serial.printf("-  Chip-Package ID: %d  ", bhdb.chipID);

  switch(bhdb.chipID){
		case EFUSE_RD_CHIP_VER_PKG_ESP32D0WDQ6:	Serial.println("-> ESP32D0WDQ6 (WROOM32)"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32D0WDQ5:	Serial.println("-> ESP32D0WDQ5 (WROVER-B)"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32D2WDQ5:	Serial.println("-> ESP32D2WDQ5"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32PICOD2:	Serial.println("-> ESP32PICOD2"); break;
		case EFUSE_RD_CHIP_VER_PKG_ESP32PICOD4:	Serial.println("-> ESP32PICOD4"); break;
		default: 	Serial.println("-> unknown"); break;
	}

  //	Serial.println(esp_efuse_get_pkg_ver(), BIN);
}

//*******************************************************************
// CheckWebPage()
/// @brief check web space for client request in case we are connected
/// send a MQTT response
/// @return void
//*******************************************************************
void CheckWebPage(){
  int i;
  String GETParameter = Webserver_GetRequestGETParameter();   // look for client request

    if (GETParameter.length() > 0){        // we got a request, client connection stays open
      BHLOG(LOGLAN) i = GETParameter.length();
      BHLOG(LOGLAN) Serial.printf("  CheckWebPage: GETParameter[%i]=", i);
      BHLOG(LOGLAN) Serial.println(GETParameter);
      if (GETParameter.length() > 1){      // request contains some GET parameter

          // decode the GET parameter and set ConfigValues
          int countValues = DecodeGETParameterAndSetConfigValues(GETParameter);
          BHLOG(LOGLAN) Serial.printf("  CheckWebPage: Interpreting <%i> parameters for %s\n", countValues, WebRequestHostAddress.c_str());

          // the user entered this address in browser, with GET parameter values for configuration
          // default: if (WebRequestHostAddress == "192.168.4.1"){
          if (WebRequestHostAddress == bhdb.ipaddr){
                // check and process 5 ConfigValues, switch the LED,
                // store SSID, Password, DeviceID and DeviceToken in non-volatile storage
                ProcessAndValidateConfigValues(5);

                // takeout SSID and Password out of non-volatile storage
                String strSSID = preferences.getString("SSID", "");
                String strPassword = preferences.getString("Password", "");

                // convert to char*: https://coderwall.com/p/zfmwsg/arduino-string-to-char
                char* txtSSID = const_cast<char*>(strSSID.c_str());
                char* txtPassword = const_cast<char*>(strPassword.c_str());
                BHLOG(LOGLAN) Serial.printf("  WebServer: Reconnect SSID:%s - PWD:%s\n", txtSSID, txtPassword);

                // disconnect from router network
//                int successDisconnect = wifi_disconnect();
                delay(1000);  // wait a second

                // then try to connect once new with new login-data
//                int successConnect = wifi_connect(txtSSID, txtPassword, HOSTNAME);
                  int successConnect =1; // shortcut for test purpose

                if (successConnect == 1){
                    RouterNetworkDeviceState = NETWORKSTATE_LOGGED;                 // set the state
                    CounterForMQTT = 0;
                }else{
                    RouterNetworkDeviceState = NETWORKSTATE_NOTLOGGED;              // set the state
                }
                MQTTClient_Connected = false;
          }
      }
      String HTMLPage;

      // the user entered this address in the browser, to get the configuration webpage
      // default: if (WebRequestHostAddress == "192.168.4.1"){
      if (WebRequestHostAddress == bhdb.ipaddr){
          // build a new Configuration webpage with form and new ConfigValues entered in textboxes or represented by sliders
          HTMLPage = EncodeFormHTMLFromValues("BeeIoT CONFIG Page", 5) +
                "<br>IP Address  : " + WiFi_GetOwnIPAddressInRouterNetwork() +
                "<br>Battery Load:";
      }
      Webserver_SendHTMLPage(HTMLPage);    // send out the webpage to client = webbrowser and close client connection
    }

/* by now no MQTT account
  if (iswifi){             // if we are logged in
    CounterForMQTT++;
    if (CounterForMQTT > 40){   // do this approx every 2 seconds
      CounterForMQTT = 0;
      // not yet connected
      if (MQTTClient_Connected == false){
        // try to connect to AllThingsTalk MQTT Broker and switch RGB-LEDs
        int NodeState = ConnectToATT();
        if (NodeState > 0){   //  connection and subscription established successfully
          MQTTClient_Connected = true;            // we can go in normal mode
        }
      }

      // we successfully connected with MQTT broker and subscribed to topic and can go in normal mode
      if (MQTTClient_Connected == true){
        // generate virtual sensor data (10..40)
        CurrentSensorDate++;
        if (CurrentSensorDate > 40) {CurrentSensorDate = 10;};

        // Send sensor data via MQTT to AllThingsTalk
        SendSensorDateToATT("temperature", CurrentSensorDate);

        // read the voltage at pin 36, divide by 64
        int analog_value = analogRead(PIN_SENSOR) >> 6;

        // Send sensor data via MQTT to AllThingsTalk
        SendSensorDateToATT("light", analog_value);
      }
    }
  }
*/
} // end of CheckWebPage()


//********************************************************************************
// wiretest()
/// @brief For test purpose only in case of HW incompatibility
/// Check for WROOM <-> Wrover ESP32 pin layout
/// @return void
//********************************************************************************
void wiretest(){
  int gpio = 36;
  int twait = 1000;

  Serial.printf(" GPIO OUT: %i: ", gpio);
  for (int i=0; i<10000; i++){
    pinMode(gpio,   OUTPUT);
    digitalWrite(gpio, LOW);
    delay(twait);
    digitalWrite(gpio, HIGH);
    delay(twait);
    Serial.printf(".");
  }
  Serial.printf("\n");

  Serial.printf(" GPIO IN: %i: ", gpio);
  pinMode(gpio,  INPUT);
  for (int i=0; i<20; i++){
    int dio = digitalRead(gpio);
    delay(twait/2);
    if(dio)
      Serial.printf("1");
    else
      Serial.printf("0");
  }
  Serial.printf("   -> Done! \n");
  while(1);
}


// end of BeeIoT main